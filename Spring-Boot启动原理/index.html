<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring Boot启动原理"><meta name="keywords" content="Spring Boot"><meta name="author" content="xiaobubuya"><meta name="copyright" content="xiaobubuya"><title>Spring Boot启动原理 | xiaobubuyaのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"X2MTDP5JXS","apiKey":"b740a5c5a0afcfdb46cd9dde3f3da169","indexName":"xiaobubuya","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="xiaobubuyaのBlog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Springboot启动流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-AOP"><span class="toc-number">2.</span> <span class="toc-text">Spring AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.0.1.</span> <span class="toc-text">AOP是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.2.</span> <span class="toc-text">AOP的应用场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#springAop%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">2.0.3.</span> <span class="toc-text">springAop的底层是怎样实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E7%BC%96%E8%AF%91%E6%97%B6%E6%9C%9F%E8%BF%9B%E8%A1%8C%E7%BB%87%E5%85%A5%EF%BC%8C%E8%BF%98%E6%98%AF%E8%BF%90%E8%A1%8C%E6%9C%9F%E8%BF%9B%E8%A1%8C%E7%BB%87%E5%85%A5%EF%BC%9F"><span class="toc-number">2.0.4.</span> <span class="toc-text">是编译时期进行织入，还是运行期进行织入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%9F%E7%BB%87%E5%85%A5%E8%BF%98%E6%98%AF%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%BB%87%E5%85%A5%EF%BC%9F"><span class="toc-number">2.0.5.</span> <span class="toc-text">初始化时期织入还是获取对象时织入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-AOP-%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%BF%98%E6%98%AFcglib%EF%BC%9F"><span class="toc-number">2.0.6.</span> <span class="toc-text">spring AOP 默认使用jdk动态代理还是cglib？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-AOP-%E5%92%8C-AspectJ%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">2.0.7.</span> <span class="toc-text">spring AOP 和 AspectJ的关系？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-number">3.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%EF%BC%8CSpringBoot%EF%BC%8CSpringMVC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.1.</span> <span class="toc-text">Spring，SpringBoot，SpringMVC的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">3.0.2.</span> <span class="toc-text">什么是自动配置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Boot-Stater-%EF%BC%9F"><span class="toc-number">3.0.3.</span> <span class="toc-text">什么是 Spring Boot Stater ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E4%BA%A7%E5%93%81%E5%B0%B1%E7%BB%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%EF%BC%9F"><span class="toc-number">3.0.4.</span> <span class="toc-text">Spring 是如何快速创建产品就绪应用程序的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81-spring-boot-maven-plugin"><span class="toc-number">3.0.5.</span> <span class="toc-text">为什么我们需要 spring-boot-maven-plugin?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-SpringBoot-%E8%87%AA%E5%8A%A8%E9%87%8D%E8%A3%85%E6%88%91%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%9F"><span class="toc-number">3.0.6.</span> <span class="toc-text">如何使用 SpringBoot 自动重装我的应用程序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%A2"><span class="toc-number">3.0.7.</span> <span class="toc-text">什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9IOC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.0.8.</span> <span class="toc-text">谈谈你对IOC的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IOC%E5%AE%B9%E5%99%A8%EF%BC%9A"><span class="toc-number">3.0.8.1.</span> <span class="toc-text">IOC容器：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%9A"><span class="toc-number">3.0.8.2.</span> <span class="toc-text">控制反转：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9A"><span class="toc-number">3.0.8.3.</span> <span class="toc-text">依赖注入：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpring-IOC-%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-number">3.0.9.</span> <span class="toc-text">什么是Spring IOC 容器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.0.10.</span> <span class="toc-text">IOC的优点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">3.0.11.</span> <span class="toc-text">什么是Spring的依赖注入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B-Controller%E5%92%8C-RestController%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.0.12.</span> <span class="toc-text">请说明一下@Controller和@RestController的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%9A"><span class="toc-number">3.0.13.</span> <span class="toc-text">Bean生命周期流程图：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.0.14.</span> <span class="toc-text">bean的实例化过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-Autowired%E8%BF%87%E7%A8%8B"><span class="toc-number">3.0.15.</span> <span class="toc-text">依赖注入@Autowired过程</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/img02/%E5%A4%B4%E5%83%8F.jpg"></div><div class="author-info__name text-center">xiaobubuya</div><div class="author-info__description text-center">命数如织，当为磐石</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/xiaobubuya">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">28</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://xiaobubuya.cn/gallery">Gallery</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://xiaobubuya.cn/slides">Slides</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/img01/jiangnan.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">xiaobubuyaのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Spring Boot启动原理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.3k</span><span class="post-meta__separator">|</span><span>Reading time: 10 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Springboot启动流程"><a href="#Springboot启动流程" class="headerlink" title="Springboot启动流程"></a>Springboot启动流程</h1><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-51aa162747fcdc3d.png" alt=""></p>
<p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/59812124e4b0de2518b32b6e">原图链接</a></p>
<p><strong>总览：</strong></p>
<p>​    上图为SpringBoot启动结构图，我们发现启动流程主要分为三个部分，第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器，第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块，第三部分是自动化配置模块，该模块作为springboot自动配置核心，在后面的分析中会详细讨论。在下面的启动程序中我们会串联起结构中的主要功能。</p>
<p><strong>启动：</strong></p>
<p>每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run()启动整个spring-boot程序，该方法所在类需要使用@SpringBootApplication注解，以及@ImportResource注解(if need)，@SpringBootApplication包括三个注解，功能如下：</p>
<p>@EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置</p>
<p>@SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境</p>
<p>@ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下</p>
<p>回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成，接下来我们来探讨自动化配置是如何实现。</p>
<p><strong>自动化配置：</strong></p>
<p>​    之前的启动结构图中，我们注意到无论是应用初始化还是具体的执行过程，都调用了SpringBoot自动配置模块</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-8f2374a500b07c6d.webp" alt=""></p>
<p>SpringBoot自动配置模块</p>
<p>​    该配置模块的主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-71e4d0e8cda64ee7.png" alt=""></p>
<p>工厂接口与其若干实现类接口名称</p>
<p>下图有助于我们形象理解自动配置流程</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-95d1af756cee57ad.png" alt=""></p>
<p>SpringBoot自动化配置关键组件关系图 </p>
<p>​    mybatis-spring-boot-starter、spring-boot-starter-web等组件的META-INF文件下均含有spring.factories文件，自动配置模块中，SpringFactoriesLoader收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。</p>
<p>之前我们提到了EnableAutoConfiguration注解，其类图如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-577bc78a48cea9ef.png" alt=""></p>
<p>可以发现其最终实现了ImportSelector(选择器)和BeanClassLoaderAware(bean类加载器中间件)，重点关注一下AutoConfigurationImportSelector的selectImports方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-05843dc2de08fefe.png" alt=""></p>
<p>该方法在springboot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的，不要急我们继续向下分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-1acb163dede80c03.png" alt=""></p>
<p>该方法中的getCandidateConfigurations方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了loadFactoryNames方法，查看该方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-0398d3354e6b91d1.png" alt=""></p>
<p>在上面的代码可以看到自动配置器会跟根据传入的factoryClass.getName()到项目系统路径下所有的spring.factories文件中找到相应的key，从而加载里面的类。我们就选取这个mybatis-spring-boot-autoconfigure下的spring.factories文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-84f04d5605c8a185.png" alt=""></p>
<p>进入org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration中，主要看一下类头</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-d836df5a3ae71c08.png" alt=""></p>
<p>发现@Spring的Configuration，俨然是一个通过注解标注的springBean，继续向下看，</p>
<p>@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class})这个注解的意思是：当存在SqlSessionFactory.class, SqlSessionFactoryBean.class这两个类时才解析MybatisAutoConfiguration配置类,否则不解析这一个配置类，make sence，我们需要mybatis为我们返回会话对象，就必须有会话工厂相关类</p>
<p>@CondtionalOnBean(DataSource.class):只有处理已经被声明为bean的dataSource</p>
<p>@ConditionalOnMissingBean(MapperFactoryBean.class)这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行（该类源码较长，篇幅限制不全粘贴）</p>
<p>​    以上配置可以保证sqlSessionFactory、sqlSessionTemplate、dataSource等mybatis所需的组件均可被自动配置，@Configuration注解已经提供了Spring的上下文环境，所以以上组件的配置方式与Spring启动时通过mybatis.xml文件进行配置起到一个效果。通过分析我们可以发现，只要一个基于SpringBoot项目的类路径下存在SqlSessionFactory.class, SqlSessionFactoryBean.class，并且容器中已经注册了dataSourceBean，就可以触发自动化配置，意思说我们只要在maven的项目中加入了mybatis所需要的若干依赖，就可以触发自动配置，但引入mybatis原生依赖的话，每集成一个功能都要去修改其自动化配置类，那就得不到开箱即用的效果了。所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖(mybatis)如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-b616bb63af52b5dd.png" alt=""></p>
<p>这里是截取的mybatis-spring-boot-starter的源码中pom.xml文件中所有依赖:</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-eeed64900a5e35c5.png" alt=""></p>
<p>因为maven依赖的传递性，我们只要依赖starter就可以依赖到所有需要自动配置的类，实现开箱即用的功能。也体现出Springboot简化了Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h3 id="AOP是什么？"><a href="#AOP是什么？" class="headerlink" title="AOP是什么？"></a>AOP是什么？</h3><p>Spring AOP(Aspect Oriented Programming，面向切面编程)是OOPs(面向对象编程)的补充，它也提供了模块化。与OOP对比，面向切面，传统的OOP开发中的代码逻辑是至上而下的过程中会长生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不会散落在代码的各个地方，造成难以维护，AOP的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高（目的是重用代码，把公共的代码抽取出来）</p>
<h3 id="AOP的应用场景有哪些？"><a href="#AOP的应用场景有哪些？" class="headerlink" title="AOP的应用场景有哪些？"></a>AOP的应用场景有哪些？</h3><p>1、日志记录</p>
<p>2、权限验证</p>
<p>3、效率检查（个人在代码上，喜欢用注解+切面，实现校验，redis分布式锁等功能）</p>
<p>4、事务管理（spring 的事务就是用AOP实现的）</p>
<h3 id="springAop的底层是怎样实现的？"><a href="#springAop的底层是怎样实现的？" class="headerlink" title="springAop的底层是怎样实现的？"></a>springAop的底层是怎样实现的？</h3><p>1、JDK动态代理</p>
<p>2、CGLIB代理</p>
<h3 id="是编译时期进行织入，还是运行期进行织入？"><a href="#是编译时期进行织入，还是运行期进行织入？" class="headerlink" title="是编译时期进行织入，还是运行期进行织入？"></a>是编译时期进行织入，还是运行期进行织入？</h3><p>运行期，生成字节码，再加载到虚拟机中，JDK是利用反射原理，CGLIB使用了ASM原理。</p>
<h3 id="初始化时期织入还是获取对象时织入？"><a href="#初始化时期织入还是获取对象时织入？" class="headerlink" title="初始化时期织入还是获取对象时织入？"></a>初始化时期织入还是获取对象时织入？</h3><p>初始化的时候，已经将目标对象进行代理，放入到spring 容器中</p>
<h3 id="spring-AOP-默认使用jdk动态代理还是cglib？"><a href="#spring-AOP-默认使用jdk动态代理还是cglib？" class="headerlink" title="spring AOP 默认使用jdk动态代理还是cglib？"></a>spring AOP 默认使用jdk动态代理还是cglib？</h3><p>要看条件，如果实现了接口的类，是使用jdk。如果没实现接口，就使用cglib。</p>
<h3 id="spring-AOP-和-AspectJ的关系？"><a href="#spring-AOP-和-AspectJ的关系？" class="headerlink" title="spring AOP 和 AspectJ的关系？"></a>spring AOP 和 AspectJ的关系？</h3><p>两者都是为了实现AOP这个目的，而出现的技术，spring aop 参考 AspectJ编程风格</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="Spring，SpringBoot，SpringMVC的区别"><a href="#Spring，SpringBoot，SpringMVC的区别" class="headerlink" title="Spring，SpringBoot，SpringMVC的区别"></a>Spring，SpringBoot，SpringMVC的区别</h3><p>SpringFramework 最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。</p>
<p>Spring MVC 提供了一种分离式的方法来开发 Web 应用。</p>
<p>Spring 和 SpringMVC 的问题在于需要配置大量的参数。Spring Boot 通过一个自动配置和启动的项来目解决这个问题。</p>
<h3 id="什么是自动配置？"><a href="#什么是自动配置？" class="headerlink" title="什么是自动配置？"></a>什么是自动配置？</h3><p>Spring 查看（CLASSPATH 上可用的框架）已存在的应用程序的配置。在此基础上，Spring Boot 提供了配置应用程序和框架所需要的基本配置。这就是自动配置</p>
<h3 id="什么是-Spring-Boot-Stater-？"><a href="#什么是-Spring-Boot-Stater-？" class="headerlink" title="什么是 Spring Boot Stater ？"></a>什么是 Spring Boot Stater ？</h3><p>这些依赖项。Spring Boot Starter Web 预先打包了这些依赖项。作为一个开发者，我不需要再担心这些依赖项和它们的兼容版本</p>
<h3 id="Spring-是如何快速创建产品就绪应用程序的？"><a href="#Spring-是如何快速创建产品就绪应用程序的？" class="headerlink" title="Spring 是如何快速创建产品就绪应用程序的？"></a>Spring 是如何快速创建产品就绪应用程序的？</h3><p>Spring Boot 致力于快速产品就绪应用程序。为此，它提供了一些譬如高速缓存，日志记录，监控和嵌入式服务器等开箱即用的非功能性特征。</p>
<h3 id="为什么我们需要-spring-boot-maven-plugin"><a href="#为什么我们需要-spring-boot-maven-plugin" class="headerlink" title="为什么我们需要 spring-boot-maven-plugin?"></a>为什么我们需要 spring-boot-maven-plugin?</h3><p>spring-boot-maven-plugin 提供了一些像 jar 一样打包或者运行应用程序的命令。</p>
<h3 id="如何使用-SpringBoot-自动重装我的应用程序？"><a href="#如何使用-SpringBoot-自动重装我的应用程序？" class="headerlink" title="如何使用 SpringBoot 自动重装我的应用程序？"></a>如何使用 SpringBoot 自动重装我的应用程序？</h3><p>把下面的依赖项添加至你的 Spring Boot Project pom.xml 中</p>
<h3 id="什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢"><a href="#什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢" class="headerlink" title="什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?"></a>什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?</h3><p>嵌入式服务器就是我们的可执行单元包含服务器的二进制文件（例如，tomcat.jar）。</p>
<p>当我们创建一个可以部署的应用程序的时候，我们将会把服务器（例如，tomcat）嵌入到可部署的服务器中。你就可以想运行正常 Java 应用程序一样来运行 web 应用程序了。</p>
<h3 id="谈谈你对IOC的理解"><a href="#谈谈你对IOC的理解" class="headerlink" title="谈谈你对IOC的理解"></a>谈谈你对IOC的理解</h3><p>容器概念、控制反转、依赖注入</p>
<h4 id="IOC容器："><a href="#IOC容器：" class="headerlink" title="IOC容器："></a>IOC容器：</h4><p>里面存的是各种对象（xml里配置的bean节点、@repository、@service、@controller、@component），项目启动时读取配置文件中的bean节点，根据类名反射创建对象到容器中，同时扫描上述注解的类通过反射对象存入容器。</p>
<p>代码中需要用到里面的对象时，再通过（autowired、resource等注解）注入。</p>
<h4 id="控制反转："><a href="#控制反转：" class="headerlink" title="控制反转："></a>控制反转：</h4><p>如果没有引入IOC容器，对象A依赖于对象B，那么对象A在初始化或者运行到某一点时，自己必须主动去创建对象B或者使用已经创建的对象B，无论是创建还是使用对象B，控制权都在自己手上。</p>
<p>引入IOC容器之后，对象A和对象B失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p>
<h4 id="依赖注入："><a href="#依赖注入：" class="headerlink" title="依赖注入："></a>依赖注入：</h4><p>依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态的将某种依赖关系注入到对象之中。</p>
<h3 id="什么是Spring-IOC-容器？"><a href="#什么是Spring-IOC-容器？" class="headerlink" title="什么是Spring IOC 容器？"></a>什么是Spring IOC 容器？</h3><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<h3 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h3><p>IOC 或 依赖注入把应用的代码量降到最低。</p>
<h3 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h3><p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p>
<h3 id="请说明一下-Controller和-RestController的区别是什么？"><a href="#请说明一下-Controller和-RestController的区别是什么？" class="headerlink" title="请说明一下@Controller和@RestController的区别是什么？"></a>请说明一下@Controller和@RestController的区别是什么？</h3><p>@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用</p>
<p>@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。</p>
<p>@Controller 处理http请求</p>
<h3 id="Bean生命周期流程图："><a href="#Bean生命周期流程图：" class="headerlink" title="Bean生命周期流程图："></a>Bean生命周期流程图：</h3><p><img src="https://uploadfiles.nowcoder.com/images/20180926/308572_1537967995043_4D7CF33471A392D943F00167D1C86C10" alt=""></p>
<p>1、实例化bean对象(通过构造方法或者工厂方法)<br>2、设置对象属性(setter等)（依赖注入）<br>3、如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）<br>4、如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身<br>5、将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法<br>6、调用Bean的初始化方法<br>7、将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法<br>8、使用Bean<br>9、容器关闭之前，调用Bean的销毁方法</p>
<h3 id="bean的实例化过程："><a href="#bean的实例化过程：" class="headerlink" title="bean的实例化过程："></a>bean的实例化过程：</h3><p>class —-&gt; 实例化 —-&gt; 对象 —-&gt; 属性填充 —-&gt; afterPropertiesSet() —-&gt; AOP —-&gt; 代理对象 —-&gt; Bean</p>
<h3 id="依赖注入-Autowired过程"><a href="#依赖注入-Autowired过程" class="headerlink" title="依赖注入@Autowired过程"></a>依赖注入@Autowired过程</h3><p>1、寻找被@Autowired注解了的方法和属性</p>
<p>2、方法注入点注入（属性注入点注入）</p>
<p>3、先按byType：按类型装配，再按byName: 按名称装配</p>
<p>4、根据方法参数找bean（根据属性参数找bean）</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">xiaobubuya</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xiaobubuya.github.io/Spring-Boot启动原理/">https://xiaobubuya.github.io/Spring-Boot启动原理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring-Boot/">Spring Boot</a></div><div class="social-share pull-right" data-disabled="facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/HashMap%E7%9B%B8%E5%85%B3/"><i class="fa fa-chevron-left">  </i><span>HashMap相关</span></a></div><div class="next-post pull-right"><a href="/TCP%E5%8D%8F%E8%AE%AE%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"><span>TCP协议三次握手四次挥手</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/img01/jiangnan.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By xiaobubuya</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>