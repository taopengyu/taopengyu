<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaobubuyaのBlog</title>
  
  <subtitle>一生一世一双人</subtitle>
  <link href="https://xiaobubuya.github.io/atom.xml" rel="self"/>
  
  <link href="https://xiaobubuya.github.io/"/>
  <updated>2021-07-25T12:51:13.239Z</updated>
  <id>https://xiaobubuya.github.io/</id>
  
  <author>
    <name>xiaobubuya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三种分布式锁的使用</title>
    <link href="https://xiaobubuya.github.io/%E4%B8%89%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BD%BF%E7%94%A8/"/>
    <id>https://xiaobubuya.github.io/%E4%B8%89%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BD%BF%E7%94%A8/</id>
    <published>2021-07-18T11:10:32.000Z</published>
    <updated>2021-07-25T12:51:13.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用分布式锁"><a href="#为什么要使用分布式锁" class="headerlink" title="为什么要使用分布式锁"></a>为什么要使用分布式锁</h2><p>在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><h2 id="分布式锁应该具备哪些条件"><a href="#分布式锁应该具备哪些条件" class="headerlink" title="分布式锁应该具备哪些条件"></a>分布式锁应该具备哪些条件</h2><p>1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；<br>2、高可用的获取锁与释放锁；<br>3、高性能的获取锁与释放锁；<br>4、具备可重入特性；<br>5、具备锁失效机制，防止死锁；<br>6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</p><h2 id="分布式锁的三种实现方式"><a href="#分布式锁的三种实现方式" class="headerlink" title="分布式锁的三种实现方式"></a>分布式锁的三种实现方式</h2><p>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p><p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。</p><blockquote><p>基于数据库实现分布式锁；<br>基于缓存（Redis等）实现分布式锁；<br>基于Zookeeper实现分布式锁；</p></blockquote><h3 id="基于数据库实现排他锁"><a href="#基于数据库实现排他锁" class="headerlink" title="基于数据库实现排他锁"></a>基于数据库实现排他锁</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `methodLock`(</span><br><span class="line">`id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">    `method_name` varchar(64) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;锁定的方法名&#x27;,</span><br><span class="line">    `desc` varchar(1024) NOT NULL DEFAULT &#x27;备注信息&#x27;,</span><br><span class="line">    `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;保存数据时间，自动生成&#x27;,</span><br><span class="line">    PRIMARY KEY(`id`),</span><br><span class="line">    UNIQUE KEY `uidx_method_name` (`method_name`)USING BTREE</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;锁定的方法&#x27;;</span><br></pre></td></tr></table></figure><p>获取锁时使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO method_lock (method_name, desc) VALUES (&#x27;methodName&#x27;, &#x27;methodName&#x27;);</span><br></pre></td></tr></table></figure><p>因为对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功。</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `method_lock` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `method_name` varchar(64) NOT NULL COMMENT &#x27;锁定的方法名&#x27;,</span><br><span class="line">  `state` tinyint NOT NULL COMMENT &#x27;1:未分配；2：已分配&#x27;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  `version` int NOT NULL COMMENT &#x27;版本号&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT=&#x27;锁定中的方法&#x27;;</span><br></pre></td></tr></table></figure><p>先获取锁的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, method_name, state,version from method_lock where state=1 and method_name=&#x27;methodName&#x27;;</span><br></pre></td></tr></table></figure><p>占有锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t_resoure set state=2, version=2, update_time=now() where method_name=&#x27;methodName&#x27; and state=1 and version=2;</span><br></pre></td></tr></table></figure><p>如果没有更新影响到一行数据，则说明这个资源已经被别人占位了。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>1、这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。<br>2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。<br>3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。<br>4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>​     1、数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。<br>​     2、没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。<br>​     3、非阻塞的？搞一个while循环，直到insert成功再返回成功。<br>​     4、非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</p><h3 id="基于redis实现"><a href="#基于redis实现" class="headerlink" title="基于redis实现"></a>基于redis实现</h3><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">lock = redisTemplate.opsForValue().setIfAbsent(lockKey, LOCK);</span><br><span class="line">logger.info(<span class="string">&quot;cancelCouponCode是否获取到锁：&quot;</span>+lock);</span><br><span class="line"><span class="keyword">if</span> (lock) &#123;</span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line">redisTemplate.expire(lockKey,<span class="number">1</span>, TimeUnit.MINUTES); <span class="comment">//成功设置过期时间</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">logger.info(<span class="string">&quot;cancelCouponCode没有获取到锁，不执行任务!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lock)&#123;</span><br><span class="line">redisTemplate.delete(lockKey);</span><br><span class="line">logger.info(<span class="string">&quot;cancelCouponCode任务结束，释放锁!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">logger.info(<span class="string">&quot;cancelCouponCode没有获取到锁，无需释放锁!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>在这种场景（主从结构）中存在明显的竞态:<br> 客户端A从master获取到锁， 在master将锁同步到slave之前，master宕掉了。slave节点被晋级为master节点，客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。安全失效！</p><h3 id="基于zookeeper实现"><a href="#基于zookeeper实现" class="headerlink" title="基于zookeeper实现"></a>基于zookeeper实现</h3><p>暂略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么要使用分布式锁&quot;&gt;&lt;a href=&quot;#为什么要使用分布式锁&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用分布式锁&quot;&gt;&lt;/a&gt;为什么要使用分布式锁&lt;/h2&gt;&lt;p&gt;在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="SpringCloud" scheme="https://xiaobubuya.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2解决方案</title>
    <link href="https://xiaobubuya.github.io/OAuth2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://xiaobubuya.github.io/OAuth2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-07-03T04:20:32.000Z</published>
    <updated>2021-07-07T03:57:15.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OAuth2解决什么问题"><a href="#OAuth2解决什么问题" class="headerlink" title="OAuth2解决什么问题"></a>OAuth2解决什么问题</h1><h2 id="OAuth2提出的背景"><a href="#OAuth2提出的背景" class="headerlink" title="OAuth2提出的背景"></a>OAuth2提出的背景</h2><p>照片拥有者想要在云冲印服务上打印照片，云冲印服务需要访问云存储服务上的资源</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/100bc1f9-5d9e-4600-9b2b-e3eb7ad7d9c5.jpg" alt=""></p><h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p>资源拥有者：照片拥有者</p><p>客户应用：云冲印</p><p>受保护的资源：照片</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/5.jpg" alt=""></p><h2 id="方式一：用户名密码复制"><a href="#方式一：用户名密码复制" class="headerlink" title="方式一：用户名密码复制"></a>方式一：用户名密码复制</h2><p>适用于同一公司内部的多个系统，不适用于不受信的第三方应用</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/6.jpg" alt=""></p><h2 id="方式二：通用开发者key"><a href="#方式二：通用开发者key" class="headerlink" title="方式二：通用开发者key"></a>方式二：通用开发者key</h2><p>适用于合作商或者授信的不同业务部门之间</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/1.jpg" alt=""></p><h2 id="方式三：办法令牌"><a href="#方式三：办法令牌" class="headerlink" title="方式三：办法令牌"></a>方式三：办法令牌</h2><p>接近OAuth2方式，需要考虑如何管理令牌、颁发令牌、吊销令牌，需要统一的协议，因此就有了OAuth2协议</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/4.jpg" alt=""></p><h1 id="现代微服务安全"><a href="#现代微服务安全" class="headerlink" title="现代微服务安全"></a>现代微服务安全</h1><p>除了开放系统授权，OAuth2还可以应用于现代微服务安全</p><h2 id="传统单块应用的安全"><a href="#传统单块应用的安全" class="headerlink" title="传统单块应用的安全"></a>传统单块应用的安全</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/7.jpg" alt=""></p><h2 id="现代微服务安全-1"><a href="#现代微服务安全-1" class="headerlink" title="现代微服务安全"></a>现代微服务安全</h2><p>现代微服务中系统微服务化以及应用的形态和设备类型增多，不能用传统的登录方式</p><p>核心的技术不是用户名和密码，而是token，由AuthServer颁发token，用户使用token进行登录</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/3.jpg" alt=""></p><h2 id="典型的OAuth2应用"><a href="#典型的OAuth2应用" class="headerlink" title="典型的OAuth2应用"></a>典型的OAuth2应用</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/2.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/summany.jpg" alt=""></p><h1 id="什么是OAuth2"><a href="#什么是OAuth2" class="headerlink" title="什么是OAuth2"></a>什么是OAuth2</h1><h2 id="OAuth2正式定义"><a href="#OAuth2正式定义" class="headerlink" title="OAuth2正式定义"></a>OAuth2正式定义</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/78c5ad4f-b313-480c-b2af-8498ef731e35.jpg" alt=""></p><h2 id="令牌的核心"><a href="#令牌的核心" class="headerlink" title="令牌的核心"></a>令牌的核心</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/6558a8b7-022f-4649-963b-85a2ec17099e.jpg" alt=""></p><h2 id="OAuth2的历史"><a href="#OAuth2的历史" class="headerlink" title="OAuth2的历史"></a>OAuth2的历史</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/1e1960bc-c516-4308-95e9-6fd34fed052b.png" alt=""></p><h2 id="OAuth2的优势"><a href="#OAuth2的优势" class="headerlink" title="OAuth2的优势"></a>OAuth2的优势</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/6afb4072-f7bd-48bb-b67a-e08528ade728.jpg" alt=""></p><h2 id="OAuth2的不足"><a href="#OAuth2的不足" class="headerlink" title="OAuth2的不足"></a>OAuth2的不足</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/8d5abdef-dcdc-4414-827c-5d30bc60c459.jpg" alt=""></p><h2 id="Auth2涉及的角色"><a href="#Auth2涉及的角色" class="headerlink" title="Auth2涉及的角色"></a>Auth2涉及的角色</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/c40e403f-3824-4867-b341-d31aca003d9e.jpg" alt=""></p><h2 id="OAuth2术语"><a href="#OAuth2术语" class="headerlink" title="OAuth2术语"></a>OAuth2术语</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/0d09fd8f-acbc-437a-8731-bc2d504e7473.png" alt=""></p><p><img src="file:///C:/Users/陶芃宇/Documents/My Knowledge/temp/c59d8b5d-fabd-4b24-b211-cc17a58993a2/128/index_files/c00b40aa-41c5-4c86-ae62-d6f4955f1522.png" alt="img"></p><h2 id="OAuth2令牌的类型"><a href="#OAuth2令牌的类型" class="headerlink" title="OAuth2令牌的类型"></a>OAuth2令牌的类型</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/7f83735b-9b05-48b9-ad16-5e314e7a1da1.jpg" alt=""></p><h2 id="OAuth2的误解"><a href="#OAuth2的误解" class="headerlink" title="OAuth2的误解"></a>OAuth2的误解</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/e816e3f7-826a-43b8-8379-f86db8e25205.jpg" alt=""></p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/294664b4-4491-454b-b4d6-7d41de10821a.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OAuth2解决什么问题&quot;&gt;&lt;a href=&quot;#OAuth2解决什么问题&quot; class=&quot;headerlink&quot; title=&quot;OAuth2解决什么问题&quot;&gt;&lt;/a&gt;OAuth2解决什么问题&lt;/h1&gt;&lt;h2 id=&quot;OAuth2提出的背景&quot;&gt;&lt;a href=&quot;#OA</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="OAuth2" scheme="https://xiaobubuya.github.io/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>配置中心介绍</title>
    <link href="https://xiaobubuya.github.io/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D/"/>
    <id>https://xiaobubuya.github.io/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-07-01T02:20:32.000Z</published>
    <updated>2021-07-09T04:11:30.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p>Spring Cloud Config 为分布式系统的外部配置提供了服务端和客户端的支持方案。在配置的服务端您可以在所有环境中为应用程序管理外部属性的中心位置。客户端和服务端概念上的Spring Environment 和 PropertySource 抽象保持同步, 它们非常适合Spring应用程序，但是可以与任何语言中运行的应用程序一起使用。当应用程序在部署管道中从一个开发到测试直至进入生产时，您可以管理这些环境之间的配置，并确保应用程序在迁移时具有它们需要运行的所有内容。服务器存储后端的默认实现使用git，因此它很容易支持标记版本的配置环境，并且能够被管理内容的各种工具访问。很容易添加替代的实现，并用Spring配置将它们插入。</p><p>Spring Cloud Config 包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。Spring cloud使用git或svn存放配置文件，默认情况下使用git。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%94%B9.jpg" alt=""></p><h2 id="Nacos替换Config"><a href="#Nacos替换Config" class="headerlink" title="Nacos替换Config"></a>Nacos替换Config</h2><p>Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config。通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。</p><p><strong>（1）应用场景</strong></p><p>在系统开发过程中，开发者通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成。配置变更是调整系统运行时的行为的有效手段。</p><p>如果微服务架构中没有使用统一配置中心时，所存在的问题：</p><p>- 配置文件分散在各个项目里，不方便维护</p><p>- 配置内容安全与权限</p><p>- 更新配置后，项目需要重启</p><p><strong>（2）nacos配置中心：</strong></p><p>系统配置的集中管理（编辑、存储、分发）、动态更新不重启、回滚配置（变更管理、历史版本管理、变更审计）等所有与配置相关的活动。</p><h2 id="读取Nacos配置中心的配置文件"><a href="#读取Nacos配置中心的配置文件" class="headerlink" title="读取Nacos配置中心的配置文件"></a>读取Nacos配置中心的配置文件</h2><h3 id="在Nacos创建统一配置文件"><a href="#在Nacos创建统一配置文件" class="headerlink" title="在Nacos创建统一配置文件"></a>在Nacos创建统一配置文件</h3><p><strong>（1）点击创建按钮</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/34c47371-40ff-4587-8655-f89b383f8632.png" alt=""></p><p><strong>（2）输入配置信息</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/f5efaf65-1c63-4ddd-93f4-09016319ee2a.png" alt=""><br><code>Data ID 的完整规则格式如下$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;- prefix** 默认为所属工程配置spring.application.name 的值（即：nacos-provider），也可以通过配置项 spring.cloud.nacos.config.prefix来配置。**- spring.profiles.active=dev** 即为当前环境对应的 profile。 注意：当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 $&#123;prefix&#125;.$&#123;file-extension&#125;**- file-exetension** 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。</code></p><h3 id="以service-statistics模块为例"><a href="#以service-statistics模块为例" class="headerlink" title="以service-statistics模块为例"></a>以service-statistics模块为例</h3><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="创建bootstrap-properties配置文件"><a href="#创建bootstrap-properties配置文件" class="headerlink" title="创建bootstrap.properties配置文件"></a>创建bootstrap.properties配置文件</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置中心地址</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="comment">#spring.profiles.active=dev</span></span><br><span class="line"><span class="comment"># 该配置影响统一配置中心中的dataId</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">service-statistics</span></span><br></pre></td></tr></table></figure><h3 id="把项目之前的application-properties内容注释，启动项目查看效果"><a href="#把项目之前的application-properties内容注释，启动项目查看效果" class="headerlink" title="把项目之前的application.properties内容注释，启动项目查看效果"></a>把项目之前的application.properties内容注释，启动项目查看效果</h3><p><strong>补充：springboot配置文件加载顺序</strong></p><p>其实yml和properties文件是一样的原理，且一个项目上要么yml或者properties，二选一的存在。推荐使用yml，更简洁。</p><p>bootstrap与application<br><strong>（1）加载顺序</strong><br>这里主要是说明application和bootstrap的加载顺序。</p><p>bootstrap.yml（bootstrap.properties）先加载</p><p>application.yml（application.properties）后加载</p><p>bootstrap.yml 用于应用程序上下文的引导阶段。</p><p>bootstrap.yml 由父Spring ApplicationContext加载。</p><p>父ApplicationContext 被加载到使用 application.yml 的之前。</p><p><strong>（2）配置区别</strong><br>bootstrap.yml 和application.yml 都可以用来配置参数。</p><p>bootstrap.yml 可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。</p><p>application.yml 可以用来定义应用级别的。</p><h2 id="名称空间切换环境"><a href="#名称空间切换环境" class="headerlink" title="名称空间切换环境"></a>名称空间切换环境</h2><p>在实际开发中，通常有多套不同的环境（默认只有public），那么这个时候可以根据指定的环境来创建不同的 namespce，例如，开发、测试和生产三个不同的环境，那么使用一套 nacos 集群可以分别建以下三个不同的 namespace。以此来实现多环境的隔离。</p><p><strong>1、创建命名空间</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/19a76d33-7bd1-4f45-a3c7-458a1f37288d.png" alt="">默认只有public，新建了dev、test和prod命名空间**</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/eb62bd69-9b4f-4e3e-8f5f-db13891ae546.png" alt=""></p><p><strong>2、克隆配置</strong></p><p>（1）切换到配置列表：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/error.png" alt=""><br>可以发现有四个名称空间：public（默认）以及我们自己添加的3个名称空间（prod、dev、test），可以点击查看每个名称空间下的配置文件，当然现在只有public下有一个配置。默认情况下，项目会到public下找 服务名.properties文件。接下来，在dev名称空间中也添加一个nacos-provider.properties配置。这时有两种方式：第一，切换到dev名称空间，添加一个新的配置文件。缺点：每个环境都要重复配置类似的项目第二，直接通过clone方式添加配置，并修改即可。推荐</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/46582e35-11b0-4946-98fe-6c182a23a4f6.png" alt="">点击编辑：修改配置内容，端口号改为8013以作区分</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/11dc46c8-a491-41d5-a374-e8644f7b7298.png" alt=""></p><p>在项目模块中，修改bootstrap.properties添加如下配置**</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment"># 该配置影响统一配置中心中的dataId，之前已经配置过</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">service-statistics</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">13b5c197-de5b-47e7-9903-ec0538c9db01</span></span><br></pre></td></tr></table></figure><p><strong>namespace的值为：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/a2eeac43-a089-452a-9228-7fbf23527ded.png" alt="">**</p><p><strong>重启服务提供方服务，测试修改之后是否生效</strong></p><h2 id="多配置文件加载"><a href="#多配置文件加载" class="headerlink" title="多配置文件加载"></a>多配置文件加载</h2><p>在一些情况下需要加载多个配置文件。假如现在dev名称空间下有三个配置文件：service-statistics.properties、redis.properties、jdbc.properties</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/aa2fe27d-fc96-430c-93c7-159b33bdd23e.png" alt=""></p><p><strong>添加配置，加载多个配置文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment"># 该配置影响统一配置中心中的dataId，之前已经配置过</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">service-statistics</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">13b5c197-de5b-47e7-9903-ec0538c9db01</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].data-id</span>=<span class="string">redis.properties</span></span><br><span class="line"><span class="comment"># 开启动态刷新配置，否则配置文件修改，工程无法感知</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[1].data-id</span>=<span class="string">jdbc.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[1].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring-Cloud-Config&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Config&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Config&quot;&gt;&lt;/a&gt;Spring Cloud Config&lt;/h2&gt;&lt;p&gt;Sp</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="SpringCloud" scheme="https://xiaobubuya.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Canal介绍</title>
    <link href="https://xiaobubuya.github.io/Canal%E4%BB%8B%E7%BB%8D/"/>
    <id>https://xiaobubuya.github.io/Canal%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-06-29T07:20:32.000Z</published>
    <updated>2021-07-07T04:01:53.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Canal介绍"><a href="#Canal介绍" class="headerlink" title="Canal介绍"></a>Canal介绍</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在前面的统计分析功能中，我们采取了服务调用获取统计数据，这样耦合度高，效率相对较低，目前我采取另一种实现方式，通过实时同步数据库表的方式实现，例如我们要统计每天注册与登录人数，我们只需把会员表同步到统计库中，实现本地统计就可以了，这样效率更高，耦合度更低，Canal就是一个很好的数据库同步工具。canal是阿里巴巴旗下的一款开源项目，纯Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持了MySQL。</p><h2 id="Canal环境搭建"><a href="#Canal环境搭建" class="headerlink" title="Canal环境搭建"></a>Canal环境搭建</h2><p><strong>canal的原理是基于mysql binlog技术，所以这里一定需要开启mysql的binlog写入功能</strong></p><p><strong>开启mysql服务：</strong>  service mysql start</p><p><strong>（1）检查binlog功能是否有开启</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_bin       | OFF    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>（2）如果显示状态为OFF表示该功能未开启，开启binlog功能</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1，修改 mysql 的配置文件 my.cnf</span><br><span class="line">vi /etc/my.cnf </span><br><span class="line">追加内容：</span><br><span class="line">log-bin=mysql-bin     #binlog文件名</span><br><span class="line">binlog_format=ROW     #选择row模式</span><br><span class="line">server_id=1           #mysql实例id,不能和canal的slaveId重复</span><br><span class="line">2，重启 mysql：</span><br><span class="line">service mysql restart   </span><br><span class="line">3，登录 mysql 客户端，查看 log_bin 变量</span><br><span class="line">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_bin       | ON|</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">————————————————</span><br><span class="line">如果显示状态为ON表示该功能已开启</span><br></pre></td></tr></table></figure><p><strong>（3）在mysql里面添加以下的相关用户和权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;canal&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;canal&#x27;;</span><br><span class="line">GRANT SHOW VIEW, SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h2 id="下载安装Canal服务"><a href="#下载安装Canal服务" class="headerlink" title="下载安装Canal服务"></a>下载安装Canal服务</h2><p>下载地址：</p><p><a href="https://github.com/alibaba/canal/releases">https://github.com/alibaba/canal/releases</a></p><p><strong>（1）下载之后，放到目录中，解压文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd `/usr/local/canal`</span><br></pre></td></tr></table></figure><p>canal.deployer-1.1.4.tar.gz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf canal.deployer-1.1.4.tar.gz</span><br></pre></td></tr></table></figure><p><strong>（2）修改配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi conf/example/instance.properties</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需要改成自己的数据库信息</span></span><br><span class="line"><span class="meta">canal.instance.master.address</span>=<span class="string">192.168.44.132:3306</span></span><br><span class="line"><span class="comment">#需要改成自己的数据库用户名与密码</span></span><br><span class="line"><span class="meta">canal.instance.dbUsername</span>=<span class="string">canal</span></span><br><span class="line"><span class="meta">canal.instance.dbPassword</span>=<span class="string">canal</span></span><br><span class="line"><span class="comment">#需要改成同步的数据库表规则，例如只是同步一下表</span></span><br><span class="line"><span class="comment">#canal.instance.filter.regex=.*\\..*</span></span><br><span class="line"><span class="meta">canal.instance.filter.regex</span>=<span class="string">guli_ucenter.ucenter_member</span></span><br></pre></td></tr></table></figure><h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><p><u>mysql 数据解析关注的表，Perl正则表达式.</u><br><u>多个正则之间以逗号(,)分隔，转义符需要双斜杠()</u><br><u>常见例子：</u></p><ol><li><u>所有表：.*   or  ...</u></li><li><u>canal schema下所有表： canal..*</u></li><li><u>canal下的以canal打头的表：canal.canal.*</u></li><li><u>canal schema下的一张表：canal.test1</u></li><li><u>多个规则组合使用：canal..*,mysql.test1,mysql.test2 (逗号分隔)</u><br><u>注意：此过滤条件只针对row模式的数据有效(ps. mixed/statement因为不解析sql，所以无法准确提取tableName进行过滤)</u></li></ol><p><strong>（3）进入bin目录下启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/startup.sh</span><br></pre></td></tr></table></figure><h1 id="创建canal-client模块"><a href="#创建canal-client模块" class="headerlink" title="创建canal_client模块"></a>创建canal_client模块</h1><h2 id="可以创建一个新的模块"><a href="#可以创建一个新的模块" class="headerlink" title="可以创建一个新的模块"></a>可以创建一个新的模块</h2><h2 id="引入相关依赖"><a href="#引入相关依赖" class="headerlink" title="引入相关依赖"></a>引入相关依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--mysql--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-dbutils&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;canal.client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="创建application-properties配置文件"><a href="#创建application-properties配置文件" class="headerlink" title="创建application.properties配置文件"></a>创建application.properties配置文件</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">10000</span></span><br><span class="line"><span class="comment"># 服务名</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">canal-client</span></span><br><span class="line"><span class="comment"># 环境设置：dev、test、prod</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment"># mysql数据库连接</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><h2 id="编写canal客户端类"><a href="#编写canal客户端类" class="headerlink" title="编写canal客户端类"></a>编写canal客户端类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.*;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.InvalidProtocolBufferException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.DbUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sql队列</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; SQL_QUEUE = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * canal入库方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CanalConnector connector = CanalConnectors.newSingleConnector(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;192.168.44.132&quot;</span>,</span><br><span class="line">                <span class="number">11111</span>), <span class="string">&quot;example&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connector.connect();</span><br><span class="line">            connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);</span><br><span class="line">            connector.rollback();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">//尝试从master那边拉去数据batchSize条记录，有多少取多少</span></span><br><span class="line">                    Message message = connector.getWithoutAck(batchSize);</span><br><span class="line">                    <span class="keyword">long</span> batchId = message.getId();</span><br><span class="line">                    <span class="keyword">int</span> size = message.getEntries().size();</span><br><span class="line">                    <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dataHandle(message.getEntries());</span><br><span class="line">                    &#125;</span><br><span class="line">                    connector.ack(batchId);</span><br><span class="line">                    <span class="comment">//当队列里面堆积的sql大于一定数值的时候就模拟执行</span></span><br><span class="line">                    <span class="keyword">if</span> (SQL_QUEUE.size() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        executeQueueSql();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟执行队列里面的sql语句</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeQueueSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = SQL_QUEUE.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            String sql = SQL_QUEUE.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;[sql]----&gt; &quot;</span> + sql);</span><br><span class="line">            <span class="keyword">this</span>.execute(sql.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entrys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dataHandle</span><span class="params">(List&lt;Entry&gt; entrys)</span> <span class="keyword">throws</span> InvalidProtocolBufferException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : entrys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (EntryType.ROWDATA == entry.getEntryType()) &#123;</span><br><span class="line">                RowChange rowChange = RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">                EventType eventType = rowChange.getEventType();</span><br><span class="line">                <span class="keyword">if</span> (eventType == EventType.DELETE) &#123;</span><br><span class="line">                    saveDeleteSql(entry);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.UPDATE) &#123;</span><br><span class="line">                    saveUpdateSql(entry);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class="line">                    saveInsertSql(entry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存更新语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveUpdateSql</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RowChange rowChange = RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();</span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowDatasList) &#123;</span><br><span class="line">                List&lt;Column&gt; newColumnList = rowData.getAfterColumnsList();</span><br><span class="line">                StringBuffer sql = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;update &quot;</span> + entry.getHeader().getTableName() + <span class="string">&quot; set &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newColumnList.size(); i++) &#123;</span><br><span class="line">                    sql.append(<span class="string">&quot; &quot;</span> + newColumnList.get(i).getName()</span><br><span class="line">                            + <span class="string">&quot; = &#x27;&quot;</span> + newColumnList.get(i).getValue() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i != newColumnList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        sql.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sql.append(<span class="string">&quot; where &quot;</span>);</span><br><span class="line">                List&lt;Column&gt; oldColumnList = rowData.getBeforeColumnsList();</span><br><span class="line">                <span class="keyword">for</span> (Column column : oldColumnList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (column.getIsKey()) &#123;</span><br><span class="line">                        <span class="comment">//暂时只支持单一主键</span></span><br><span class="line">                        sql.append(column.getName() + <span class="string">&quot;=&quot;</span> + column.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                SQL_QUEUE.add(sql.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存删除语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveDeleteSql</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RowChange rowChange = RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();</span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowDatasList) &#123;</span><br><span class="line">                List&lt;Column&gt; columnList = rowData.getBeforeColumnsList();</span><br><span class="line">                StringBuffer sql = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;delete from &quot;</span> + entry.getHeader().getTableName() + <span class="string">&quot; where &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (Column column : columnList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (column.getIsKey()) &#123;</span><br><span class="line">                        <span class="comment">//暂时只支持单一主键</span></span><br><span class="line">                        sql.append(column.getName() + <span class="string">&quot;=&quot;</span> + column.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                SQL_QUEUE.add(sql.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存插入语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveInsertSql</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RowChange rowChange = RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();</span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowDatasList) &#123;</span><br><span class="line">                List&lt;Column&gt; columnList = rowData.getAfterColumnsList();</span><br><span class="line">                StringBuffer sql = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;insert into &quot;</span> + entry.getHeader().getTableName() + <span class="string">&quot; (&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnList.size(); i++) &#123;</span><br><span class="line">                    sql.append(columnList.get(i).getName());</span><br><span class="line">                    <span class="keyword">if</span> (i != columnList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        sql.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sql.append(<span class="string">&quot;) VALUES (&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnList.size(); i++) &#123;</span><br><span class="line">                    sql.append(<span class="string">&quot;&#x27;&quot;</span> + columnList.get(i).getValue() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (i != columnList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        sql.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sql.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                SQL_QUEUE.add(sql.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == sql) <span class="keyword">return</span>;</span><br><span class="line">            con = dataSource.getConnection();</span><br><span class="line">            QueryRunner qr = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">            <span class="keyword">int</span> row = qr.execute(con, sql);</span><br><span class="line">            System.out.println(<span class="string">&quot;update: &quot;</span>+ row);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DbUtils.closeQuietly(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalApplication</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CanalClient canalClient;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CanalApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//项目启动，执行canal客户端监听</span></span><br><span class="line">        canalClient.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Canal介绍&quot;&gt;&lt;a href=&quot;#Canal介绍&quot; class=&quot;headerlink&quot; title=&quot;Canal介绍&quot;&gt;&lt;/a&gt;Canal介绍&lt;/h1&gt;&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="SpringCloud" scheme="https://xiaobubuya.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>网关基本概念和应用</title>
    <link href="https://xiaobubuya.github.io/%E7%BD%91%E5%85%B3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/"/>
    <id>https://xiaobubuya.github.io/%E7%BD%91%E5%85%B3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8/</id>
    <published>2021-06-28T04:20:32.000Z</published>
    <updated>2021-07-11T13:39:40.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网关基本概念"><a href="#网关基本概念" class="headerlink" title="网关基本概念"></a>网关基本概念</h1><h2 id="API网关介绍"><a href="#API网关介绍" class="headerlink" title="API网关介绍"></a>API网关介绍</h2><p>API 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：</p><p>（1）客户端会多次请求不同的微服务，增加了客户端的复杂性。</p><p>（2）存在跨域请求，在一定场景下处理相对复杂。</p><p>（3）认证复杂，每个服务都需要独立认证。</p><p>（4）难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。</p><p>（5）某些微服务可能使用了防火墙 / 浏览器不友好的协议，直接访问会有一定的困难。</p><p>以上这些问题可以借助 API 网关解决。API 网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性</p><h2 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h2><p><strong>Spring cloud gateway</strong>是spring官方基于Spring 5.0、Spring Boot2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控/埋点、限流等。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/10fde967-d265-42b9-b023-a735963b0205.jpg" alt=""></p><h2 id="Spring-Cloud-Gateway核心概念"><a href="#Spring-Cloud-Gateway核心概念" class="headerlink" title="Spring Cloud Gateway核心概念"></a>Spring Cloud Gateway核心概念</h2><p>网关提供API全托管服务，丰富的API管理功能，辅助企业管理大规模的API，以降低管理成本和安全风险，包括协议适配、协议转发、安全策略、防刷、流量、监控日志等贡呢。一般来说网关对外暴露的URL或者接口信息，我们统称为路由信息。如果研发过网关中间件或者使用过Zuul的人，会知道网关的核心是Filter以及Filter Chain（Filter责任链）。Sprig Cloud Gateway也具有路由和Filter的概念。下面介绍一下Spring Cloud Gateway中几个重要的概念。</p><p>（1）路由。路由是网关最基础的部分，路由信息有一个ID、一个目的URL、一组断言和一组Filter组成。如果断言路由为真，则说明请求的URL和配置匹配</p><p>（2）断言。Java8中的断言函数。Spring Cloud Gateway中的断言函数输入类型是Spring5.0框架中的ServerWebExchange。Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于http request中的任何信息，比如请求头和参数等。</p><p>（3）过滤器。一个标准的Spring webFilter。Spring cloud gateway中的filter分为两种类型的Filter，分别是Gateway Filter和Global Filter。过滤器Filter将会对请求和响应进行修改处理</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/t2.jpg" alt=""></p><p>如上图所示，Spring cloud Gateway发出请求。然后再由Gateway Handler Mapping中找到与请求相匹配的路由，将其发送到Gateway web handler。Handler再通过指定的过滤器链将请求发送到我们实际的服务执行业务逻辑，然后返回。</p><h1 id="创建api-gateway模块"><a href="#创建api-gateway模块" class="headerlink" title="创建api-gateway模块"></a>创建api-gateway模块</h1><h2 id="网关服务创建"><a href="#网关服务创建" class="headerlink" title="网关服务创建"></a>网关服务创建</h2><h3 id="在infrastructure模块下创建api-gateway模块"><a href="#在infrastructure模块下创建api-gateway模块" class="headerlink" title="在infrastructure模块下创建api_gateway模块"></a>在infrastructure模块下创建api_gateway模块</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/2537b086-dc28-44d0-8580-2521d2c0b33d.png" alt=""></p><h3 id="在pom-xml引入依赖"><a href="#在pom-xml引入依赖" class="headerlink" title="在pom.xml引入依赖"></a>在pom.xml引入依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.atguigu&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;common_utils&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--gson--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--服务调用--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="编写application-properties配置文件"><a href="#编写application-properties配置文件" class="headerlink" title="编写application.properties配置文件"></a>编写application.properties配置文件</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8222</span></span><br><span class="line"><span class="comment"># 服务名</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">service-gateway</span></span><br><span class="line"><span class="comment"># nacos服务地址</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="comment">#使用服务发现路由</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.discovery.locator.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#服务路由名小写</span></span><br><span class="line"><span class="comment">#spring.cloud.gateway.discovery.locator.lower-case-service-id=true</span></span><br><span class="line"><span class="comment">#设置路由id</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[0].id</span>=<span class="string">service-acl</span></span><br><span class="line"><span class="comment">#设置路由的uri</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[0].uri</span>=<span class="string">lb://service-acl</span></span><br><span class="line"><span class="comment">#设置路由断言,代理servicerId为auth-service的/auth/路径</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[0].predicates</span>= <span class="string">Path=/*/acl/**</span></span><br><span class="line"><span class="comment">#配置service-edu服务</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[1].id</span>=<span class="string">service-edu</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[1].uri</span>=<span class="string">lb://service-edu</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[1].predicates</span>= <span class="string">Path=/eduservice/**</span></span><br><span class="line"><span class="comment">#配置service-ucenter服务</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[2].id</span>=<span class="string">service-ucenter</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[2].uri</span>=<span class="string">lb://service-ucenter</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[2].predicates</span>= <span class="string">Path=/ucenterservice/**</span></span><br><span class="line"><span class="comment">#配置service-ucenter服务</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[3].id</span>=<span class="string">service-cms</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[3].uri</span>=<span class="string">lb://service-cms</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[3].predicates</span>= <span class="string">Path=/cmsservice/**</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[4].id</span>=<span class="string">service-msm</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[4].uri</span>=<span class="string">lb://service-msm</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[4].predicates</span>= <span class="string">Path=/edumsm/**</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[5].id</span>=<span class="string">service-order</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[5].uri</span>=<span class="string">lb://service-order</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[5].predicates</span>= <span class="string">Path=/orderservice/**</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[6].id</span>=<span class="string">service-order</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[6].uri</span>=<span class="string">lb://service-order</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[6].predicates</span>= <span class="string">Path=/orderservice/**</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[7].id</span>=<span class="string">service-oss</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[7].uri</span>=<span class="string">lb://service-oss</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[7].predicates</span>= <span class="string">Path=/eduoss/**</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[8].id</span>=<span class="string">service-statistic</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[8].uri</span>=<span class="string">lb://service-statistic</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[8].predicates</span>= <span class="string">Path=/staservice/**</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[9].id</span>=<span class="string">service-vod</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[9].uri</span>=<span class="string">lb://service-vod</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[9].predicates</span>= <span class="string">Path=/eduvod/**</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[10].id</span>=<span class="string">service-edu</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[10].uri</span>=<span class="string">lb://service-edu</span></span><br><span class="line"><span class="meta">spring.cloud.gateway.routes[10].predicates</span>= <span class="string">Path=/eduuser/**</span></span><br></pre></td></tr></table></figure><h3 id="yml文件："><a href="#yml文件：" class="headerlink" title="yml文件："></a>yml文件：</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8222</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">SERVICE-ACL</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://SERVICE-ACL</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/*/acl/**</span> <span class="comment"># 路径匹配</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">SERVICE-EDU</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://SERVICE-EDU</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/eduservice/**</span> <span class="comment"># 路径匹配</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">SERVICE-UCENTER</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://SERVICE-UCENTER</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/ucenter/**</span> <span class="comment"># 路径匹配</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><h3 id="编写启动类"><a href="#编写启动类" class="headerlink" title="编写启动类"></a>编写启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网关相关配置"><a href="#网关相关配置" class="headerlink" title="网关相关配置"></a>网关相关配置</h2><h3 id="网关解决跨域问题，创建配置类"><a href="#网关解决跨域问题，创建配置类" class="headerlink" title="网关解决跨域问题，创建配置类"></a>网关解决跨域问题，创建配置类</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/25718906-9518-4e35-9848-d2f10c079389.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsWebFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource(<span class="keyword">new</span> PathPatternParser());</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局Filter，统一处理会员登录与外部不允许访问的服务"><a href="#全局Filter，统一处理会员登录与外部不允许访问的服务" class="headerlink" title="全局Filter，统一处理会员登录与外部不允许访问的服务"></a>全局Filter，统一处理会员登录与外部不允许访问的服务</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/20210711183815.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.JsonObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.buffer.DataBuffer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.AntPathMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 全局Filter，统一处理会员登录与外部不允许访问的服务</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AntPathMatcher antPathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        String path = request.getURI().getPath();</span><br><span class="line">        <span class="comment">//谷粒学院api接口，校验用户必须登录</span></span><br><span class="line">        <span class="keyword">if</span>(antPathMatcher.match(<span class="string">&quot;/api/**/auth/**&quot;</span>, path)) &#123;</span><br><span class="line">            List&lt;String&gt; tokenList = request.getHeaders().get(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == tokenList) &#123;</span><br><span class="line">                ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">                <span class="keyword">return</span> out(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                Boolean isCheck = JwtUtils.checkToken(tokenList.get(0));</span></span><br><span class="line"><span class="comment">//                if(!isCheck) &#123;</span></span><br><span class="line">                    ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">                    <span class="keyword">return</span> out(response);</span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内部服务接口，不允许外部访问</span></span><br><span class="line">        <span class="keyword">if</span>(antPathMatcher.match(<span class="string">&quot;/**/inner/**&quot;</span>, path)) &#123;</span><br><span class="line">            ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">            <span class="keyword">return</span> out(response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Mono&lt;Void&gt; <span class="title">out</span><span class="params">(ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        JsonObject message = <span class="keyword">new</span> JsonObject();</span><br><span class="line">        message.addProperty(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">        message.addProperty(<span class="string">&quot;code&quot;</span>, <span class="number">28004</span>);</span><br><span class="line">        message.addProperty(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;鉴权失败&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bits = message.toString().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        DataBuffer buffer = response.bufferFactory().wrap(bits);</span><br><span class="line">        <span class="comment">//response.setStatusCode(HttpStatus.UNAUTHORIZED);</span></span><br><span class="line">        <span class="comment">//指定编码，否则在浏览器中会中文乱码</span></span><br><span class="line">        response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h3><p>服务网关调用服务时可能会有一些异常或服务不可用，它返回错误信息不友好，需要我们覆盖处理</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/20210711183749.png" alt=""></p><h4 id="ErrorHandlerConfig："><a href="#ErrorHandlerConfig：" class="headerlink" title="ErrorHandlerConfig："></a>ErrorHandlerConfig：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ObjectProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.ResourceProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.ServerProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.reactive.error.ErrorAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.reactive.error.ErrorWebExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.codec.ServerCodecConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.result.view.ViewResolver;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 覆盖默认的异常处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ServerProperties.class, ResourceProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorHandlerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerProperties serverProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerCodecConfigurer serverCodecConfigurer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorHandlerConfig</span><span class="params">(ServerProperties serverProperties,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     ResourceProperties resourceProperties,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        ServerCodecConfigurer serverCodecConfigurer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverProperties = serverProperties;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">        <span class="keyword">this</span>.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);</span><br><span class="line">        <span class="keyword">this</span>.serverCodecConfigurer = serverCodecConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorWebExceptionHandler <span class="title">errorWebExceptionHandler</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line">        JsonExceptionHandler exceptionHandler = <span class="keyword">new</span> JsonExceptionHandler(</span><br><span class="line">                errorAttributes,</span><br><span class="line">                <span class="keyword">this</span>.resourceProperties,</span><br><span class="line">                <span class="keyword">this</span>.serverProperties.getError(),</span><br><span class="line">                <span class="keyword">this</span>.applicationContext);</span><br><span class="line">        exceptionHandler.setViewResolvers(<span class="keyword">this</span>.viewResolvers);</span><br><span class="line">        exceptionHandler.setMessageWriters(<span class="keyword">this</span>.serverCodecConfigurer.getWriters());</span><br><span class="line">        exceptionHandler.setMessageReaders(<span class="keyword">this</span>.serverCodecConfigurer.getReaders());</span><br><span class="line">        <span class="keyword">return</span> exceptionHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonExceptionHandler："><a href="#JsonExceptionHandler：" class="headerlink" title="JsonExceptionHandler："></a>JsonExceptionHandler：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.ErrorProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.ResourceProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.reactive.error.DefaultErrorWebExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.reactive.error.ErrorAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;异常时用JSON代替HTML异常信息&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonExceptionHandler</span> <span class="keyword">extends</span> <span class="title">DefaultErrorWebExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonExceptionHandler</span><span class="params">(ErrorAttributes errorAttributes, ResourceProperties resourceProperties,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ErrorProperties errorProperties, ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorAttributes, resourceProperties, errorProperties, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取异常属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(ServerRequest request, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>, <span class="number">20005</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;网关失败&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;data&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定响应处理方法为JSON处理的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorAttributes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="title">getRoutingFunction</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(RequestPredicates.all(), <span class="keyword">this</span>::renderErrorResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据code获取对应的HttpStatus</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorAttributes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HttpStatus <span class="title">getHttpStatus</span><span class="params">(Map&lt;String, Object&gt; errorAttributes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网关基本概念&quot;&gt;&lt;a href=&quot;#网关基本概念&quot; class=&quot;headerlink&quot; title=&quot;网关基本概念&quot;&gt;&lt;/a&gt;网关基本概念&lt;/h1&gt;&lt;h2 id=&quot;API网关介绍&quot;&gt;&lt;a href=&quot;#API网关介绍&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="SpringCloud" scheme="https://xiaobubuya.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>单点登录和Spring Security</title>
    <link href="https://xiaobubuya.github.io/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%92%8CSpring%20Security/"/>
    <id>https://xiaobubuya.github.io/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%92%8CSpring%20Security/</id>
    <published>2021-06-18T11:20:32.000Z</published>
    <updated>2021-07-08T13:03:33.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单点登录常见方式"><a href="#单点登录常见方式" class="headerlink" title="单点登录常见方式"></a>单点登录常见方式</h1><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.jpg" alt=""></p><h1 id="Spring-Security介绍"><a href="#Spring-Security介绍" class="headerlink" title="Spring Security介绍"></a>Spring Security介绍</h1><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括<strong>用户认证</strong>（<strong>Authentication</strong>）和<strong>用户授权</strong>（<strong>Authorization</strong>）两个部分。</p><p>（1）用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。</p><p>（2）用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p><p><strong>Spring Security其实就是用filter，多请求的路径进行过滤。</strong></p><p>（1）如果是基于Session，那么Spring-security会对cookie里的sessionid进行解析，找到服务器存储的sesion信息，然后判断当前用户是否符合请求的要求。</p><p>（2）如果是token，则是解析出token，然后将当前请求加入到Spring-security管理的权限信息中去</p><h2 id="认证与授权实现思路"><a href="#认证与授权实现思路" class="headerlink" title="认证与授权实现思路"></a>认证与授权实现思路</h2><p>如果系统的模块众多，每个模块都需要就行授权与认证，所以我们选择基于token的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key，权限列表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中，每次调用api接口都默认将token携带到header请求头中，Spring-security解析header头获取token信息，解析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring-security就能够判断当前请求是否有权限访问</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单点登录常见方式&quot;&gt;&lt;a href=&quot;#单点登录常见方式&quot; class=&quot;headerlink&quot; title=&quot;单点登录常见方式&quot;&gt;&lt;/a&gt;单点登录常见方式&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaobubu</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="SpringCloud" scheme="https://xiaobubuya.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Nacos、Feign、Hystrix基本应用</title>
    <link href="https://xiaobubuya.github.io/Nacos%E3%80%81Feign%E3%80%81Hystrix%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <id>https://xiaobubuya.github.io/Nacos%E3%80%81Feign%E3%80%81Hystrix%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/</id>
    <published>2021-06-14T02:20:32.000Z</published>
    <updated>2021-07-07T04:03:28.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>（1）</strong>Nacos 是阿里巴巴推出来的一个新开源项目，是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><p><strong>（2）</strong>常见的注册中心：</p><ol><li><p>Eureka（原生，2.0遇到性能瓶颈，停止维护）</p></li><li><p>Zookeeper（支持，专业的独立产品。例如：dubbo）</p></li><li><p>Consul（原生，GO语言开发）</p></li><li><p>Nacos</p></li></ol><p>相对于 Spring Cloud Eureka 来说，Nacos 更强大。Nacos = Spring Cloud Eureka + Spring Cloud Config</p><p> Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config</p><p>- 通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。</p><p><strong>（3）</strong>Nacos是以服务为主要服务对象的中间件，Nacos支持所有主流的服务发现、配置和管理。</p><p>Nacos主要提供以下四大功能：</p><ol><li><p>服务发现和服务健康监测</p></li><li><p>动态配置服务</p></li><li><p>动态DNS服务</p></li><li><p>服务及其元数据管理</p></li></ol><p><strong>（4）</strong>Nacos结构图</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/nacos.jpg" alt=""></p><h2 id="Nacos下载和安装"><a href="#Nacos下载和安装" class="headerlink" title="Nacos下载和安装"></a>Nacos下载和安装</h2><p><strong>（1）下载地址和版本</strong></p><p>下载地址：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>下载版本：nacos-server-1.1.4.tar.gz或nacos-server-1.1.4.zip，解压任意目录即可</p><h2 id="启动nacos服务"><a href="#启动nacos服务" class="headerlink" title="启动nacos服务"></a>启动nacos服务</h2><p>- Linux/Unix/Mac</p><p>启动命令(standalone代表着单机模式运行，非集群模式)</p><p>启动命令：sh startup.sh -m standalone</p><p>- Windows</p><p>启动命令：cmd startup.cmd 或者双击startup.cmd运行文件。</p><p>访问：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a></p><p>用户名密码：nacos/nacos</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><h3 id="在模块配置pom"><a href="#在模块配置pom" class="headerlink" title="在模块配置pom"></a>在模块配置pom</h3><p>配置Nacos客户端的pom依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--服务注册--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="添加服务配置信息"><a href="#添加服务配置信息" class="headerlink" title="添加服务配置信息"></a>添加服务配置信息</h3><p>配置application.properties，在客户端微服务中添加注册Nacos服务的配置信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nacos服务地址</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure><p>在客户端微服务启动类中添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure><h3 id="启动客户端微服务"><a href="#启动客户端微服务" class="headerlink" title="启动客户端微服务"></a>启动客户端微服务</h3><p>启动注册中心</p><p>启动已注册的微服务，可以在Nacos服务列表中看到被注册的微服务</p><h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>Feign是Netflix开发的声明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、优雅地调用HTTP API。</li><li>Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等。</li><li>Spring Cloud对Feign进行了增强，使Feign支持了Spring MVC注解，并整合了Ribbon和Eureka，从而让Feign的使用更加方便。</li><li>Spring Cloud Feign是基于Netflix feign实现，整合了Spring Cloud Ribbon和Spring Cloud Hystrix，除了提供这两者的强大功能外，还提供了一种声明式的Web服务客户端定义的方式。</li><li>Spring Cloud Feign帮助我们定义和实现依赖服务接口的定义。在Spring Cloud feign的实现下，只需要创建一个接口并用注解方式配置它，即可完成服务提供方的接口绑定，简化了在使用Spring Cloud Ribbon时自行封装服务调用客户端的开发量。</li></ul><h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><h3 id="添加pom依赖"><a href="#添加pom依赖" class="headerlink" title="添加pom依赖"></a>添加pom依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--服务调用--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="在调用端的启动类添加注解"><a href="#在调用端的启动类添加注解" class="headerlink" title="在调用端的启动类添加注解"></a>在调用端的启动类添加注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br></pre></td></tr></table></figure><h3 id="创建包和接口"><a href="#创建包和接口" class="headerlink" title="创建包和接口"></a>创建包和接口</h3><p>创建client包</p><p>@FeignClient注解用于指定从哪个服务中调用功能 ，名称与被调用的服务名保持一致。</p><p>@GetMapping注解用于对被调用的微服务进行地址映射。</p><p>@PathVariable注解一定要指定参数名称，否则出错</p><p>@Component注解防止，在其他位置注入CodClient时idea报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guli.edu.client;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;service-vod&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VodClient</span> </span>&#123;</span><br><span class="line"><span class="meta">@DeleteMapping(value = &quot;/eduvod/vod/video/&#123;videoId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">removeVideo</span><span class="params">(<span class="meta">@PathVariable(&quot;videoId&quot;)</span> String videoId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就可以调用cilent中的方法了（先注入再调用）</p><h1 id="Hystrix基本概念"><a href="#Hystrix基本概念" class="headerlink" title="Hystrix基本概念"></a>Hystrix基本概念</h1><h2 id="Spring-Cloud调用接口过程"><a href="#Spring-Cloud调用接口过程" class="headerlink" title="Spring Cloud调用接口过程"></a>Spring Cloud调用接口过程</h2><p>Spring Cloud 在接口调用上，大致会经过如下几个组件配合：</p><p><strong><code>Feign</code> ——-&gt;<code>Hystrix</code> —&gt;<code>Ribbon</code> —&gt;<code>Http Client``（apache http components 或者 Okhttp）</code></strong> 具体交互流程上，如下图所示：</p><p><strong>（1）接口化请求调用</strong>当调用被<code>@FeignClient</code>注解修饰的接口时，在框架内部，将请求转换成Feign的请求实例<code>feign.Request</code>，交由Feign框架处理。</p><p><strong>（2）Feign</strong> ：转化请求Feign是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求，封装了Http调用流程。</p><p><strong>（3）Hystrix</strong>：熔断处理机制 Feign的调用关系，会被Hystrix代理拦截，对每一个Feign调用请求，Hystrix都会将其包装成<code>HystrixCommand</code>,参与Hystrix的流控和熔断规则。如果请求判断需要熔断，则Hystrix直接熔断，抛出异常或者使用<code>FallbackFactory</code>返回熔断<code>Fallback</code>结果；如果通过，则将调用请求传递给<code>Ribbon</code>组件。</p><p><strong>（4）Ribbon</strong>：服务地址选择 当请求传递到<code>Ribbon</code>之后,<code>Ribbon</code>会根据自身维护的服务列表，根据服务的服务质量，如平均响应时间，Load等，结合特定的规则，从列表中挑选合适的服务实例，选择好机器之后，然后将机器实例的信息请求传递给<code>Http Client</code>客户端，<code>HttpClient</code>客户端来执行真正的Http接口调用；</p><p><strong>（5）HttpClient</strong> ：Http客户端，真正执行Http调用根据上层<code>Ribbon</code>传递过来的请求，已经指定了服务地址，则HttpClient开始执行真正的Http请求</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/Spring%20Cloud%20%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8.jpg" alt=""></p><h2 id="Hystrix概念"><a href="#Hystrix概念" class="headerlink" title="Hystrix概念"></a><strong>Hystrix概念</strong></h2><p>Hystrix 是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。</p><p>比如系统中有很多服务，当某些服务不稳定的时候，使用这些服务的用户线程将会阻塞，如果没有隔离机制，系统随时就有可能会挂掉，从而带来很大的风险。SpringCloud使用Hystrix组件提供断路器、资源隔离与自我修复功能。下图表示服务B触发了断路器，阻止了级联失败。</p><h2 id="feign结合Hystrix使用"><a href="#feign结合Hystrix使用" class="headerlink" title="feign结合Hystrix使用"></a><strong>feign</strong>结合Hystrix使用</h2><h3 id="pom中添加依赖"><a href="#pom中添加依赖" class="headerlink" title="pom中添加依赖"></a>pom中添加依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!--hystrix依赖，主要是用  <span class="meta">@HystrixCommand</span> --&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!--服务注册--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;!--服务调用--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="在配置文件中添加hystrix配置"><a href="#在配置文件中添加hystrix配置" class="headerlink" title="在配置文件中添加hystrix配置"></a>在配置文件中添加hystrix配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启熔断机制</span></span><br><span class="line"><span class="meta">feign.hystrix.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#设置hystrix超时时间，默认1000ms</span></span><br><span class="line"><span class="meta">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>=<span class="string">6000</span></span><br></pre></td></tr></table></figure><h3 id="client包里面创建熔断器的实现类"><a href="#client包里面创建熔断器的实现类" class="headerlink" title="client包里面创建熔断器的实现类"></a>client包里面创建熔断器的实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VodFileDegradeFeignClient</span> <span class="keyword">implements</span> <span class="title">VodClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">removeVideo</span><span class="params">(String videoId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.error().message(<span class="string">&quot;time out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">removeVideoList</span><span class="params">(List videoIdList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.error().message(<span class="string">&quot;time out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改VodClient接口的注解"><a href="#修改VodClient接口的注解" class="headerlink" title="修改VodClient接口的注解"></a>修改VodClient接口的注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;service-vod&quot;, fallback = VodFileDegradeFeignClient.class)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nacos&quot;&gt;&lt;a href=&quot;#Nacos&quot; class=&quot;headerlink&quot; title=&quot;Nacos&quot;&gt;&lt;/a&gt;Nacos&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="SpringCloud" scheme="https://xiaobubuya.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>MQ运行原理和消息确认机制</title>
    <link href="https://xiaobubuya.github.io/MQ%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6/"/>
    <id>https://xiaobubuya.github.io/MQ%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2021-06-14T02:20:32.000Z</published>
    <updated>2021-07-08T13:02:23.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQ运行原理"><a href="#MQ运行原理" class="headerlink" title="MQ运行原理"></a>MQ运行原理</h1><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/MessageQueue.jpg" alt=""></p><h1 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h1><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/eduOnline/MQ%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6.jpg" alt=""></p><p>注：图先放这里文字描述以后有更深的理解之后再加入</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MQ运行原理&quot;&gt;&lt;a href=&quot;#MQ运行原理&quot; class=&quot;headerlink&quot; title=&quot;MQ运行原理&quot;&gt;&lt;/a&gt;MQ运行原理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaobubuya/image</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="SpringCloud" scheme="https://xiaobubuya.github.io/tags/SpringCloud/"/>
    
    <category term="Message Queue" scheme="https://xiaobubuya.github.io/tags/Message-Queue/"/>
    
  </entry>
  
  <entry>
    <title>Spring整合redis及其使用</title>
    <link href="https://xiaobubuya.github.io/Spring%E6%95%B4%E5%90%88redis%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/"/>
    <id>https://xiaobubuya.github.io/Spring%E6%95%B4%E5%90%88redis%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</id>
    <published>2021-06-13T08:30:40.000Z</published>
    <updated>2021-07-03T08:46:54.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring整合redis及其使用"><a href="#Spring整合redis及其使用" class="headerlink" title="Spring整合redis及其使用"></a>Spring整合redis及其使用</h1><h2 id="一、Redis介绍"><a href="#一、Redis介绍" class="headerlink" title="一、Redis介绍"></a>一、Redis介绍</h2><p>Redis是当前比较热门的NOSQL系统之一，它是一个开源的使用ANSI c语言编写的key-value存储系统（区别于MySQL的二维表格的形式存储。）。和Memcache类似，但很大程度补偿了Memcache的不足。和Memcache一样，Redis数据都是缓存在计算机内存中，不同的是，Memcache只能将数据缓存到内存中，无法自动定期写入硬盘，这就表示，一断电或重启，内存清空，数据丢失。所以Memcache的应用场景适用于缓存无需持久化的数据。而Redis不同的是它会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现数据的持久化。</p><p>Redis的特点：</p><p>1，Redis读取的速度是110000次/s，写的速度是81000次/s；</p><p>2，原子 。Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p><p>3，支持多种数据结构：string（字符串）；list（列表）；hash（哈希），set（集合）；zset(有序集合)</p><p>4，持久化，集群部署</p><p>5，支持过期时间，支持事务，消息订阅</p><p>（RedisTemplate、@Cacheable注解）</p><h2 id="二、所需依赖及常见配置"><a href="#二、所需依赖及常见配置" class="headerlink" title="二、所需依赖及常见配置"></a>二、所需依赖及常见配置</h2><h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- redis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="properties常用redis配置"><a href="#properties常用redis配置" class="headerlink" title="properties常用redis配置"></a>properties常用redis配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.44.132</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><h2 id="三、使用方式"><a href="#三、使用方式" class="headerlink" title="三、使用方式"></a>三、使用方式</h2><h3 id="1、使用RedisTemplate"><a href="#1、使用RedisTemplate" class="headerlink" title="1、使用RedisTemplate"></a>1、使用RedisTemplate</h3><p>该方式操作redis需要一个RedisConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        <span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">              .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以封装一个RedisUtil快捷使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于spring和redis的redisTemplate工具类</span></span><br><span class="line"><span class="comment"> * 针对所有的hash 都是以h开头的方法</span></span><br><span class="line"><span class="comment"> * 针对所有的Set 都是以s开头的方法                    不含通用方法</span></span><br><span class="line"><span class="comment"> * 针对所有的List 都是以l开头的方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Component</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----------------公共方法 Start-----------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给一个指定的 key 值附加过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除指定key 的过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">persist</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.boundValueOps(key).persist();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------公共方法 End-----------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------String类型 Start-----------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="keyword">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将值放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将值放入缓存并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) -1为无期限</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量添加 key (重复的键会覆盖)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyAndValue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchSet</span><span class="params">(Map&lt;String, String&gt; keyAndValue)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().multiSet(keyAndValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量添加 key-value 只有在键不存在时,才添加</span></span><br><span class="line"><span class="comment">     * map 中只要有一个key存在,则全部不添加</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyAndValue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchSetIfAbsent</span><span class="params">(Map&lt;String, String&gt; keyAndValue)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().multiSetIfAbsent(keyAndValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对一个 key-value 的值进行加减操作,</span></span><br><span class="line"><span class="comment">     * 如果该 key 不存在 将创建一个key 并赋值该 number</span></span><br><span class="line"><span class="comment">     * 如果 key 存在,但 value 不是长整型 ,将报错</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">increment</span><span class="params">(String key, <span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对一个 key-value 的值进行加减操作,</span></span><br><span class="line"><span class="comment">     * 如果该 key 不存在 将创建一个key 并赋值该 number</span></span><br><span class="line"><span class="comment">     * 如果 key 存在,但 value 不是 纯数字 ,将报错</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">increment</span><span class="params">(String key, <span class="keyword">double</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------String类型 End-----------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------Set类型 Start-----------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sSet</span><span class="params">(String key, Set&lt;String&gt; value)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForSet().add(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取变量中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">members</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机获取变量中指定个数的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">randomMembers</span><span class="params">(String key, <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForSet().randomMembers(key, count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机获取变量中的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">randomMember</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().randomMember(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出变量中的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().pop(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取变量中值的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sHasKey</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的元素是否在变量中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 元素对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMember</span><span class="params">(String key, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转移变量的元素值到目的变量。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   元素对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey 元素对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">(String key, String value, String destKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().move(key, value, destKey);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量移除set缓存中元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过给定的key求2个set变量的差值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Set&gt; <span class="title">difference</span><span class="params">(String key, String destKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().difference(key, destKey);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------Set类型 End-----------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------Hash类型 Start-----------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 下的 所有  hashkey 和 value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">getHashEntries</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证指定 key 下 有没有指定的 hashkey</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hashKey</span><span class="params">(String key, String hashKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, hashKey);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定key的值string</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key2 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMapString</span><span class="params">(String key, String key2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key,key2).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定的值Int</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key2 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMapInt</span><span class="params">(String key, String key2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Integer) redisTemplate.opsForHash().get(key, key2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定 hash 的 HashKey</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKeys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除成功的 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">delete</span><span class="params">(String key, String... hashKeys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().delete(key, hashKeys);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给指定 hash 的 hashkey 做增减操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">increment</span><span class="params">(String key, String hashKey, <span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, hashKey, number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给指定 hash 的 hashkey 做增减操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">increment</span><span class="params">(String key, String hashKey, Double number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, hashKey, number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 下的 所有 hashkey 字段</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">hashKeys</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().keys(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定 hash 下面的 键值对 数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">hashSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().size(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------Hash类型 End-----------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------list类型 Start-----------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在变量左边添加元素值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftPush</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForList().leftPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合指定位置的值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">index</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().index(<span class="string">&quot;list&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定区间的值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">range</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把最后一个参数值放到指定集合的第一个出现中间参数的前面，</span></span><br><span class="line"><span class="comment">     * 如果中间参数值存在的话。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pivot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftPush</span><span class="params">(String key, String pivot, String value)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForList().leftPush(key, pivot, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向左边批量添加参数元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftPushAll</span><span class="params">(String key, String... values)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        redisTemplate.opsForList().leftPushAll(key,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;);</span></span><br><span class="line">        redisTemplate.opsForList().leftPushAll(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向集合最右边添加元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftPushAll</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向左边批量添加参数元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightPushAll</span><span class="params">(String key, String... values)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//redisTemplate.opsForList().leftPushAll(key,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;);</span></span><br><span class="line">        redisTemplate.opsForList().rightPushAll(key, values);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向已存在的集合中添加元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightPushIfPresent</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForList().rightPushIfPresent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向已存在的集合中添加元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">listLength</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除集合中的左边第一个元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftPop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForList().leftPop(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除集合中左边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftPop</span><span class="params">(String key, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForList().leftPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除集合中右边的元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightPop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForList().rightPop(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除集合中右边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightPop</span><span class="params">(String key, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForList().rightPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------list类型 End-----------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、使用注解缓存"><a href="#2、使用注解缓存" class="headerlink" title="2、使用注解缓存"></a>2、使用注解缓存</h3><h4 id="（1）缓存-Cacheable"><a href="#（1）缓存-Cacheable" class="headerlink" title="（1）缓存@Cacheable"></a>（1）缓存@Cacheable</h4><p>根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。</p><p>查看源码，属性值如下：</p><div class="table-container"><table><thead><tr><th><strong>属性/方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table></div><h4 id="（2）缓存-CachePut"><a href="#（2）缓存-CachePut" class="headerlink" title="（2）缓存@CachePut"></a>（2）缓存@CachePut</h4><p>使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。</p><p>查看源码，属性值如下：</p><div class="table-container"><table><thead><tr><th><strong>属性/方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr></tbody></table></div><h4 id="（3）缓存-CacheEvict"><a href="#（3）缓存-CacheEvict" class="headerlink" title="（3）缓存@CacheEvict"></a>（3）缓存@CacheEvict</h4><p>使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上</p><p>查看源码，属性值如下：</p><div class="table-container"><table><thead><tr><th><strong>属性/方法名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>value</td><td>缓存名，必填，它指定了你的缓存存放在哪块命名空间</td></tr><tr><td>cacheNames</td><td>与 value 差不多，二选一即可</td></tr><tr><td>key</td><td>可选属性，可以使用 SpEL 标签自定义缓存的key</td></tr><tr><td>allEntries</td><td>是否清空所有缓存，默认为 false。如果指定为 true，则方法调用后将立即清空所有的缓存</td></tr><tr><td>beforeInvocation</td><td>是否在方法执行前就清空，默认为 false。如果指定为 true，则在方法执行前就会清空缓存</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring整合redis及其使用&quot;&gt;&lt;a href=&quot;#Spring整合redis及其使用&quot; class=&quot;headerlink&quot; title=&quot;Spring整合redis及其使用&quot;&gt;&lt;/a&gt;Spring整合redis及其使用&lt;/h1&gt;&lt;h2 id=&quot;一、Red</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Redis" scheme="https://xiaobubuya.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>EasyExcel的使用</title>
    <link href="https://xiaobubuya.github.io/EasyExcel%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://xiaobubuya.github.io/EasyExcel%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2021-06-10T08:43:41.000Z</published>
    <updated>2021-07-03T08:46:03.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EasyExcel的使用"><a href="#EasyExcel的使用" class="headerlink" title="EasyExcel的使用"></a>EasyExcel的使用</h1><h2 id="一、Excel导入导出的应用场景"><a href="#一、Excel导入导出的应用场景" class="headerlink" title="一、Excel导入导出的应用场景"></a>一、Excel导入导出的应用场景</h2><p>1、数据导入：减轻录入工作量</p><p>2、数据导出：统计信息归档</p><p>3、数据传输：异构系统之间数据传输</p><h2 id="二、EasyExcel简介"><a href="#二、EasyExcel简介" class="headerlink" title="二、EasyExcel简介"></a>二、EasyExcel简介</h2><h3 id="EasyExcel特点"><a href="#EasyExcel特点" class="headerlink" title="EasyExcel特点"></a>EasyExcel特点</h3><ul><li>Java领域解析、生成Excel比较有名的框架有Apache poi、jxl等。但他们都存在一个严重的问题就是非常的耗内存。如果你的系统并发量不大的话可能还行，但是一旦并发上来后一定会OOM或者JVM频繁的full gc。</li><li>EasyExcel是阿里巴巴开源的一个excel处理框架，<strong>以使用简单、节省内存著称</strong>。EasyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部加载到内存中，而是从磁盘上一行行读取数据，逐个解析。</li><li>EasyExcel采用一行一行的解析模式，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）。</li></ul><h2 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h2><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;</span></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.1</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="创建实体类，设置表头和添加的数据字段"><a href="#创建实体类，设置表头和添加的数据字段" class="headerlink" title="创建实体类，设置表头和添加的数据字段"></a>创建实体类，设置表头和添加的数据字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置表头和添加的数据字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoData</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置表头名称</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;学生编号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sno;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//设置表头名称</span></span><br><span class="line"><span class="meta">@ExcelProperty(&quot;学生姓名&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String sname;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSno</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSno</span><span class="params">(<span class="keyword">int</span> sno)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sno = sno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSname</span><span class="params">(String sname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sname = sname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DemoData&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;sno=&quot;</span> + sno +</span><br><span class="line">            <span class="string">&quot;, sname=&#x27;&quot;</span> + sname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写入Excel操作"><a href="#写入Excel操作" class="headerlink" title="写入Excel操作"></a>写入Excel操作</h3><h4 id="写法一、"><a href="#写法一、" class="headerlink" title="写法一、"></a>写法一、</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 写法1</span></span><br><span class="line">    String fileName = <span class="string">&quot;F:\\11.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">    <span class="comment">// 如果这里想使用03 则 传入excelType参数即可</span></span><br><span class="line">    EasyExcel.write(fileName, DemoData.class).sheet(<span class="string">&quot;写入方法一&quot;</span>).doWrite(data());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 写法2，方法二需要手动关闭流</span></span><br><span class="line">    String fileName = <span class="string">&quot;F:\\112.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写</span></span><br><span class="line">    ExcelWriter excelWriter = EasyExcel.write(fileName, DemoData.class).build();</span><br><span class="line">    WriteSheet writeSheet = EasyExcel.writerSheet(<span class="string">&quot;写入方法二&quot;</span>).build();</span><br><span class="line">    excelWriter.write(data(), writeSheet);</span><br><span class="line">    <span class="comment">/// 千万别忘记finish 会帮忙关闭流</span></span><br><span class="line">    excelWriter.finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对Excel进行读操作"><a href="#对Excel进行读操作" class="headerlink" title="对Excel进行读操作"></a>对Excel进行读操作</h3><h4 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadData</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置列对应的属性</span></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sid;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置列对应的属性</span></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> String sname;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSid</span><span class="params">(<span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sid = sid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSname</span><span class="params">(String sname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sname = sname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ReadData&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;sid=&quot;</span> + sid +</span><br><span class="line">                <span class="string">&quot;, sname=&#x27;&quot;</span> + sname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建读取操作的监听器"><a href="#创建读取操作的监听器" class="headerlink" title="创建读取操作的监听器"></a>创建读取操作的监听器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.exception.ExcelDataConvertException;</span><br><span class="line"><span class="keyword">import</span> com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建读取excel监听器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">ReadData</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建list集合封装最终的数据</span></span><br><span class="line">    List&lt;ReadData&gt; list = <span class="keyword">new</span> ArrayList&lt;ReadData&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一行一行去读取excle内容</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(ReadData user, AnalysisContext analysisContext)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;***&quot;</span>+user);</span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取excel表头信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeHeadMap</span><span class="params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;表头信息：&quot;</span>+headMap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取完成后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用实现最终的读取"><a href="#调用实现最终的读取" class="headerlink" title="调用实现最终的读取"></a>调用实现最终的读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写法1：</span></span><br><span class="line">        String fileName = <span class="string">&quot;F:\\01.xlsx&quot;</span>;</span><br><span class="line">        <span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span></span><br><span class="line">        EasyExcel.read(fileName, ReadData.class, <span class="keyword">new</span> ExcelListener()).sheet().doRead();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 写法2：</span></span><br><span class="line">        InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;F:\\01.xlsx&quot;</span>));</span><br><span class="line">        ExcelReader excelReader = EasyExcel.read(in, ReadData.class, <span class="keyword">new</span> ExcelListener()).build();</span><br><span class="line">        ReadSheet readSheet = EasyExcel.readSheet(<span class="number">0</span>).build();</span><br><span class="line">        excelReader.read(readSheet);</span><br><span class="line">        <span class="comment">// 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的</span></span><br><span class="line">        excelReader.finish();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;EasyExcel的使用&quot;&gt;&lt;a href=&quot;#EasyExcel的使用&quot; class=&quot;headerlink&quot; title=&quot;EasyExcel的使用&quot;&gt;&lt;/a&gt;EasyExcel的使用&lt;/h1&gt;&lt;h2 id=&quot;一、Excel导入导出的应用场景&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="EasyExcel" scheme="https://xiaobubuya.github.io/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>windows下RocketMQ下载安装教程及异步发送邮件</title>
    <link href="https://xiaobubuya.github.io/windows%E4%B8%8BRocketMQ%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%8F%8A%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <id>https://xiaobubuya.github.io/windows%E4%B8%8BRocketMQ%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%8F%8A%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</id>
    <published>2021-06-10T04:20:32.000Z</published>
    <updated>2021-07-03T08:47:46.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="windows下RocketMQ下载安装教程及异步发送邮件"><a href="#windows下RocketMQ下载安装教程及异步发送邮件" class="headerlink" title="windows下RocketMQ下载安装教程及异步发送邮件"></a>windows下RocketMQ下载安装教程及异步发送邮件</h1><h2 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h2><p>1、官网下载：<a href="http://rocketmq.apache.org/dowloading/releases/">http://rocketmq.apache.org/dowloading/releases/</a></p><p>2、百度网盘下载链接：<a href="https://pan.baidu.com/s/13WQeU3c8jIx8ArkfrG4kEw">https://pan.baidu.com/s/13WQeU3c8jIx8ArkfrG4kEw</a> </p><p>提取码：abcd</p><h2 id="二、安装及启动"><a href="#二、安装及启动" class="headerlink" title="二、安装及启动"></a>二、安装及启动</h2><p>1、前提条件：已安装jdk1.8及maven</p><p>2、将下载下的安装文件解压到本地磁盘</p><p>3、配置环境变量</p><p>变量名：ROCKETMQ_HOME</p><p>变量值：D:\rocketmq-all-4.4.0-bin-release（输入你的解压路径）</p><p>Path中添加：%ROCKETMQ_HOME%\bin</p><p>4、启动NAMESERVER和BROKER</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start mqnamesrv.cmd</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true</span><br></pre></td></tr></table></figure><p> 启动BROKER。成功后会弹出提示框，勿关闭。</p><h1 id="三、安装可视化插件"><a href="#三、安装可视化插件" class="headerlink" title="三、安装可视化插件"></a>三、安装可视化插件</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、github下载：<a href="https://codeload.github.com/apache/rocketmq-externals/zip/master">https://codeload.github.com/apache/rocketmq-externals/zip/master</a> </p><p>2、百度网盘链接：<a href="https://pan.baidu.com/s/1KXgWZsre2610vkEvrxR9Dw">https://pan.baidu.com/s/1KXgWZsre2610vkEvrxR9Dw</a><br>提取码：abcd</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>1、解压后application.properties文件可以修改配置，主要是监听和服务端口号</p><p>2、rocketmq-console文件夹下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>3、生成target文件夹，在文件夹下执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar rocketmq-console-ng-1.0.1.jar</span><br></pre></td></tr></table></figure><p>启动服务</p><h2 id="四、异步发送邮件"><a href="#四、异步发送邮件" class="headerlink" title="四、异步发送邮件"></a>四、异步发送邮件</h2><h3 id="1、pom文件中引入依赖"><a href="#1、pom文件中引入依赖" class="headerlink" title="1、pom文件中引入依赖"></a>1、pom文件中引入依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.1</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2、application-properties"><a href="#2、application-properties" class="headerlink" title="2、application.properties"></a>2、application.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mq</span></span><br><span class="line"><span class="comment">#rocketmq服务地址</span></span><br><span class="line"><span class="meta">rocketmq.name-server</span>=<span class="string">127.0.0.1:9876  </span></span><br><span class="line"><span class="meta">rocketmq.producer.group</span>=<span class="string">group</span></span><br><span class="line"><span class="meta">rocketmq.producer.send-message-timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">rocketmq.consumer.group</span>=<span class="string">group</span></span><br><span class="line"><span class="meta">rocketmq.topic</span>=<span class="string">TopicEmail</span></span><br></pre></td></tr></table></figure><h3 id="3、controller层发送邮箱验证码"><a href="#3、controller层发送邮箱验证码" class="headerlink" title="3、controller层发送邮箱验证码"></a>3、controller层发送邮箱验证码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送邮箱验证的方法</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/sendEmail/&#123;email&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">emailCode</span><span class="params">(<span class="meta">@PathVariable</span> String email)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//String code = redisTemplate.opsForValue().get(email);</span></span><br><span class="line">    <span class="comment">//if(!StringUtils.isEmpty(code)) return Result.ok();</span></span><br><span class="line">    code = RandomUtil.getFourBitRandom();</span><br><span class="line"></span><br><span class="line">    asyncSend(mqTopic, <span class="string">&quot;TagA&quot;</span>, code+<span class="string">&#x27;|&#x27;</span>+email);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步发送消息</span></span><br><span class="line"><span class="comment"> * 可靠异步发送：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式；</span></span><br><span class="line"><span class="comment"> * 特点：速度快；有结果反馈；数据可靠；</span></span><br><span class="line"><span class="comment"> * 应用场景：异步发送一般用于链路耗时较长,对 rt响应时间较为敏感的业务场景,例如用户视频上传后通知启动转码服务,转码完成后通知推送转码结果等；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncSend</span><span class="params">(String topic, String tags, String body)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//判断Topic和body是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(topic)||StringUtils.isEmpty(body)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rocketMQTemplate.asyncSend(topic, body, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>+sendResult.getSendStatus());</span><br><span class="line">            <span class="comment">//更新用户状态</span></span><br><span class="line">            <span class="comment">//mailSendLogsService.updateStatus(msgId,1);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO 消息发送失败，定义一个定时器定时去发送消息</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要注入以下几个bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;rocketmq.topic&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String mqTopic;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;rocketmq.producer.send-message-timeout&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br></pre></td></tr></table></figure><p>生成随机验证码的工具类供参考</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DecimalFormat fourdf = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DecimalFormat sixdf = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;000000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFourBitRandom</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fourdf.format(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSixBitRandom</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sixdf.format(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">getRandom</span><span class="params">(List list, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 生成随机数字并存入HashMap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> number = random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">            hashMap.put(number, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从HashMap导入数组</span></span><br><span class="line">        Object[] robjs = hashMap.values().toArray();</span><br><span class="line">        ArrayList r = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">// 遍历数组并打印数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            r.add(list.get((<span class="keyword">int</span>)robjs[i]) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、消费者"><a href="#4、消费者" class="headerlink" title="4、消费者"></a>4、消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(consumerGroup = &quot;group&quot;,</span></span><br><span class="line"><span class="meta">        topic = &quot;TopicEmail&quot;,</span></span><br><span class="line"><span class="meta">        selectorExpression=&quot;*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailServer</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageExt</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate&lt;String,String&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MsmService msmService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageExt message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">        String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        String[] strs = msg.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">        <span class="comment">//接收到消息发送邮件</span></span><br><span class="line">        msmService.sendEmailCode(strs[<span class="number">1</span>],strs[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、发送邮件"><a href="#5、发送邮件" class="headerlink" title="5、发送邮件"></a>5、发送邮件</h3><p>service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">sendEmailCode</span><span class="params">(String email, String code)</span></span>;</span><br></pre></td></tr></table></figure><p>Impl 邮箱号和口令填写自己的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送邮箱</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendEmailCode</span><span class="params">(String email, String code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建Properties 类用于记录邮箱的一些属性</span></span><br><span class="line">        <span class="keyword">final</span> Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//表示SMTP发送邮件，必须进行身份验证</span></span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.auth&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="comment">//此处填写SMTP服务器</span></span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.host&quot;</span>, <span class="string">&quot;smtp.qq.com&quot;</span>);</span><br><span class="line">        <span class="comment">//端口号，QQ邮箱给出了两个端口，这里给出587</span></span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.port&quot;</span>, <span class="string">&quot;587&quot;</span>);</span><br><span class="line">        <span class="comment">//此处填写你的账号</span></span><br><span class="line">        props.put(<span class="string">&quot;mail.user&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//此处的密码就是前面说的16位STMP口令</span></span><br><span class="line">        <span class="comment">//获取口令</span></span><br><span class="line">        props.put(<span class="string">&quot;mail.password&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//构建授权信息，用于进行SMTP进行身份验证</span></span><br><span class="line">        Authenticator authenticator = <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 用户名、密码</span></span><br><span class="line">                String userName = props.getProperty(<span class="string">&quot;mail.user&quot;</span>);</span><br><span class="line">                String password = props.getProperty(<span class="string">&quot;mail.password&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(userName, password);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//使用环境属性和授权信息，创建邮件会话</span></span><br><span class="line">        Session mailSession = Session.getInstance(props, authenticator);</span><br><span class="line">        <span class="comment">//创建邮件消息</span></span><br><span class="line">        MimeMessage message = <span class="keyword">new</span> MimeMessage(mailSession);</span><br><span class="line">        <span class="comment">//设置发件人</span></span><br><span class="line">        InternetAddress form = <span class="keyword">new</span> InternetAddress(props.getProperty(<span class="string">&quot;mail.user&quot;</span>));</span><br><span class="line">        message.setFrom(form);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置收件人的邮箱</span></span><br><span class="line">        InternetAddress to = <span class="keyword">new</span> InternetAddress(email);</span><br><span class="line">        message.setRecipient(Message.RecipientType.TO, to);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置邮件主题</span></span><br><span class="line">        message.setSubject(<span class="string">&quot;小不不学院登录注册验证&quot;</span>);</span><br><span class="line">        <span class="comment">//设置消息日期</span></span><br><span class="line">        message.setSentDate(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//html文件</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;h1&gt;小不不学院验证码&lt;/h1&gt;&quot;</span>+<span class="string">&quot;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;</span>+<span class="string">&quot;你好：&lt;/p&gt;&quot;</span>+<span class="string">&quot;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;你的验证码是&quot;</span>+ code +<span class="string">&quot;你可凭此验证码登录。&lt;/p&gt;&quot;</span>+<span class="string">&quot;&lt;h3&gt;小不不学院发&lt;/h3&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//设置邮件的内容体</span></span><br><span class="line">        message.setContent(sb.toString(), <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后当然就是发送邮件</span></span><br><span class="line">        Transport.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送失败！&quot;</span>+e.getMessage());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;windows下RocketMQ下载安装教程及异步发送邮件&quot;&gt;&lt;a href=&quot;#windows下RocketMQ下载安装教程及异步发送邮件&quot; class=&quot;headerlink&quot; title=&quot;windows下RocketMQ下载安装教程及异步发送邮件&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="RocketMQ" scheme="https://xiaobubuya.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud相关概念介绍</title>
    <link href="https://xiaobubuya.github.io/SpringCloud%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"/>
    <id>https://xiaobubuya.github.io/SpringCloud%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-06-10T04:20:32.000Z</published>
    <updated>2021-07-07T03:56:11.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h1><h2 id="微服务的由来"><a href="#微服务的由来" class="headerlink" title="微服务的由来"></a>微服务的由来</h2><p>微服务最早由Martin Fowler与James Lewis于2014年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。 </p><h2 id="为什么需要微服务"><a href="#为什么需要微服务" class="headerlink" title="为什么需要微服务"></a>为什么需要微服务</h2><p>在传统的IT行业软件大多都是各种独立系统的堆砌，这些系统的问题总结来说就是扩展性差，可靠性不高，维护成本高。到后面引入了SOA服务化，但是，由于 SOA 早期均使用了总线模式，这种总线模式是与某种技术栈强绑定的，比如：J2EE。这导致很多企业的遗留系统很难对接，切换时间太长，成本太高，新系统稳定性的收敛也需要一些时间。 </p><h2 id="微服务与单体架构区别"><a href="#微服务与单体架构区别" class="headerlink" title="微服务与单体架构区别"></a>微服务与单体架构区别</h2><p>（1）单体架构所有的模块全都耦合在一块，代码量大，维护困难。</p><p>​     微服务每个模块就相当于一个单独的项目，代码量明显减少，遇到问题也相对来说比较好解决。</p><p>（2）单体架构所有的模块都共用一个数据库，存储方式比较单一。</p><p>​     微服务每个模块都可以使用不同的存储方式（比如有的用redis，有的用mysql等），数据库也是单个模块对应自己的数据库。</p><p>（3）单体架构所有的模块开发所使用的技术一样。</p><p>​     微服务每个模块都可以使用不同的开发技术，开发模式更灵活。 </p><h2 id="微服务本质"><a href="#微服务本质" class="headerlink" title="微服务本质"></a>微服务本质</h2><p>（1）微服务，关键其实不仅仅是微服务本身，而是系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级，不仅如此，这个系统架构还让微服务与微服务之间在结构上“松耦合”，而在功能上则表现为一个统一的整体。这种所谓的“统一的整体”表现出来的是统一风格的界面，统一的权限管理，统一的安全策略，统一的上线过程，统一的日志和审计方法，统一的调度方式，统一的访问入口等等。<br>（2）微服务的目的是有效的拆分应用，实现敏捷开发和部署 。<br>（3）微服务提倡的理念团队间应该是 inter-operate, not integrate 。inter-operate是定义好系统的边界和接口，在一个团队内全栈，让团队自治，原因就是因为如果团队按照这样的方式组建，将沟通的成本维持在系统内部，每个子系统就会更加内聚，彼此的依赖耦合能变弱，跨系统的沟通成本也就能降低。</p><h2 id="什么样的项目适合微服务"><a href="#什么样的项目适合微服务" class="headerlink" title="什么样的项目适合微服务"></a>什么样的项目适合微服务</h2><p>微服务可以按照业务功能本身的独立性来划分，如果系统提供的业务是非常底层的，如：操作系统内核、存储系统、网络系统、数据库系统等等，这类系统都偏底层，功能和功能之间有着紧密的配合关系，如果强制拆分为较小的服务单元，会让集成工作量急剧上升，并且这种人为的切割无法带来业务上的真正的隔离，所以无法做到独立部署和运行，也就不适合做成微服务了。</p><p>6、微服务开发框架</p><p>目前微服务的开发框架，最常用的有以下四个：</p><p>Spring Cloud：<a href="http://projects.spring.io/spring-cloud（现在非常流行的微服务架构）">http://projects.spring.io/spring-cloud（现在非常流行的微服务架构）</a></p><p>Dubbo：http：//dubbo.io</p><p>Dropwizard：<a href="http://www.dropwizard.io">http://www.dropwizard.io</a> （关注单个微服务的开发）</p><p>Consul、etcd&amp;etc.（微服务的模块）</p><h2 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h2><p>Spring Cloud是一系列框架的集合。它利用Spring Boot的开发便利性简化了分布式系统基础设施的开发，如服务发现、服务注册、配置中心、消息总线、负载均衡、 熔断器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过SpringBoot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包</p><h2 id="Spring-Cloud和Spring-Boot是什么关系"><a href="#Spring-Cloud和Spring-Boot是什么关系" class="headerlink" title="Spring Cloud和Spring Boot是什么关系"></a>Spring Cloud和Spring Boot是什么关系</h2><p>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的开发工具；Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，必须基于Spring Boot开发。可以单独使用Spring Boot开发项目，但是Spring Cloud离不开 Spring Boot。</p><h2 id="Spring-Cloud相关基础服务组件"><a href="#Spring-Cloud相关基础服务组件" class="headerlink" title="Spring Cloud相关基础服务组件"></a>Spring Cloud相关基础服务组件</h2><p>服务发现——Netflix Eureka （Nacos）</p><p>服务调用——Netflix Feign </p><p>熔断器——Netflix Hystrix </p><p>服务网关——Spring Cloud GateWay </p><p>分布式配置——Spring Cloud Config  （Nacos）</p><p>消息总线 —— Spring Cloud Bus （Nacos）</p><h2 id="Spring-Cloud的版本"><a href="#Spring-Cloud的版本" class="headerlink" title="Spring Cloud的版本"></a>Spring Cloud的版本</h2><p>Spring Cloud并没有熟悉的数字版本号，而是对应一个开发代号。</p><div class="table-container"><table><thead><tr><th>Cloud代号</th><th>Boot版本(train)</th><th>Boot版本(tested)</th><th>lifecycle</th></tr></thead><tbody><tr><td>Angle</td><td>1.2.x</td><td>incompatible with 1.3</td><td>EOL in July 2017</td></tr><tr><td>Brixton</td><td>1.3.x</td><td>1.4.x</td><td>2017-07卒</td></tr><tr><td>Camden</td><td>1.4.x</td><td>1.5.x</td><td>-</td></tr><tr><td>Dalston</td><td>1.5.x</td><td>not expected 2.x</td><td>-</td></tr><tr><td>Edgware</td><td>1.5.x</td><td>not expected 2.x</td><td>-</td></tr><tr><td>Finchley</td><td>2.0.x</td><td>not expected 1.5.x</td><td>-</td></tr><tr><td>Greenwich</td><td><strong>2.1.x</strong></td><td></td><td></td></tr><tr><td>Hoxton</td><td>2.2.x</td><td></td></tr></tbody></table></div><p>开发代号看似没有什么规律，但实际上首字母是有顺序的，比如：Dalston版本，我们可以简称 D 版本，对应的 Edgware 版本我们可以简称 E 版本。</p><h2 id="小版本"><a href="#小版本" class="headerlink" title="小版本"></a>小版本</h2><p>Spring Cloud 小版本分为:</p><p>SNAPSHOT： 快照版本，随时可能修改</p><p>M： MileStone，M1表示第1个里程碑版本，一般同时标注PRE，表示预览版版。</p><p>SR： Service Release，SR1表示第1个正式版本，一般同时标注GA：(GenerallyAvailable),表示稳定版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是微服务&quot;&gt;&lt;a href=&quot;#什么是微服务&quot; class=&quot;headerlink&quot; title=&quot;什么是微服务&quot;&gt;&lt;/a&gt;什么是微服务&lt;/h1&gt;&lt;h2 id=&quot;微服务的由来&quot;&gt;&lt;a href=&quot;#微服务的由来&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="项目" scheme="https://xiaobubuya.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="SpringCloud" scheme="https://xiaobubuya.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Java面试汇总</title>
    <link href="https://xiaobubuya.github.io/Java%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    <id>https://xiaobubuya.github.io/Java%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</id>
    <published>2021-05-09T12:55:19.000Z</published>
    <updated>2021-06-02T01:40:25.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java容器"><a href="#Java容器" class="headerlink" title="Java容器"></a>Java容器</h1><h3 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h3><p>List：有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出所有元素，再逐一遍历，还可以使用get（int index）获取指定下标的元素。</p><p>Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用iterator接口取得所有元素，再逐一遍历各个元素。</p><h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h3><p>ArrayList：基于动态数组，连续内存存储，适合下标访问，扩容机制：因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动</p><p>LinkedList：基于链表，可以存储在分散的内存中，适合数据插入和删除，不适合查询：需要注意遍历。遍历LinkedList必须使用iterator不能使用for循环，因为for循环体内通过get（i）都要重新遍历，性能消耗大。</p><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>修饰类：表示类不可被继承</p><p>修饰方法：表示方法不可被子类覆盖，但是可以重载</p><p>修饰变量：表示变量一旦被复制就不可以更改</p><h2 id="equals与"><a href="#equals与" class="headerlink" title="equals与=="></a>equals与==</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>对于基本数据类型，==比较的是值是否相等；</p><p>对于引用类型来说，==比较的是两者在内存中存放的地址；</p><p>对于引用类型来说，如果equals未被重写，对比的是他们的地址是否相等，若被重写（例如String）比较的是地址里的内容。</p><p>对于包装类型，equals首先比较的是否为同类型，非同类型直接返回false，同类型再比较值。</p><h3 id="hashCode（）与equals（）"><a href="#hashCode（）与equals（）" class="headerlink" title="hashCode（）与equals（）"></a>hashCode（）与equals（）</h3><p>hashCode（）作用是获取哈希码，作用是确认该对象在哈希表中的索引位置。hashCode（）定义在Object类中，即Java中任何类都包含hashCode（）函数。</p><h3 id="为什么重写equals时要重写hashCode（）"><a href="#为什么重写equals时要重写hashCode（）" class="headerlink" title="为什么重写equals时要重写hashCode（）"></a>为什么重写equals时要重写hashCode（）</h3><p>两个对象内容完全相同，hashCode不一定相同，此时单重写equals（），可以比较出两个对象相同，但是容器不会认为两者相同；</p><p>HashSet或HashMap在添加对象的时候，依然认为这两个对象不等；</p><p>重写hashCode函数后，让两个对象内容完全相同的时候，hashCode也相同，这样容器在添加元素的时候，就会认为这两个对象相等了。</p><h2 id="拆箱和装箱"><a href="#拆箱和装箱" class="headerlink" title="拆箱和装箱"></a>拆箱和装箱</h2><h3 id="自动拆箱和装箱"><a href="#自动拆箱和装箱" class="headerlink" title="自动拆箱和装箱"></a>自动拆箱和装箱</h3><p>自动装箱通过包装类的valueOf（）方法来实现。自动拆箱通过包装类的xxxValue（）来实现。</p><p>好处：方便（不用考虑包装类和基本类型的转换），节约空间（常量池）。</p><h3 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h3><p>（1）场景1：基本数据类型放入集合类 —将基本类型自动装箱</p><p>（2）场景2：包装类与基本类型进行运算 —先将包装类进行拆箱成基本类型，然后进行比较</p><p>（3）场景3：包装类型之间的运算，会被自动拆箱成基本类型进行。</p><p>（4）场景5：函数参数与返回值 —这里会自动拆箱装箱为返回的类型。</p><h3 id="自动装拆箱带来的问题"><a href="#自动装拆箱带来的问题" class="headerlink" title="自动装拆箱带来的问题"></a>自动装拆箱带来的问题</h3><p>1、==比较问题</p><p>在一定范围内可以进行比较，更多的时候还是要用equals</p><p>2、空指针问题</p><p>初始包装类型对象为null，拆箱会报NPE（NullPointerException）</p><p>3、内存浪费</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1000</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">    sum + = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>+操作先拆箱，得到的结果赋值给sum，会进行装箱，会产生大量无用对象造成内存空间浪费，加重了垃圾回收的工作量。</p><h3 id="Integer缓存机制"><a href="#Integer缓存机制" class="headerlink" title="Integer缓存机制"></a>Integer缓存机制</h3><p>目的：有助于节省内存、提高性能。</p><p>Integer存在常量值，一次性把-128到127之间所有数都初始化缓存了，==比较的是内存地址，当赋值没有超过范围，内存地址都是常量池的地址，超过了最大缓存量后，各自new一个对象，此时地址不一样。</p><h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><p>字符型 char （16bit）</p><p>布尔型 boolean </p><p>整型 byte short int long （8，16，32，64）</p><p>浮点型 float double （32，64）</p><h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2><p>String是不可变对象，每次对String类型对象更改相当于新生成一个String对象。</p><p>StringBuffer线程安全，StringBuilder非线程安全，速度快。这两个类型的对象可以被多次修改，不会产生新的对象。都不允许直接赋空值，但是构造函数可以赋空值。</p><h3 id="String生成几个对象"><a href="#String生成几个对象" class="headerlink" title="String生成几个对象"></a>String生成几个对象</h3><p>String str1 = “123”，最少创建0个对象，最多创建1个对象。当我们栈中的str1想用“123”这个常量时，先去方法区中的常量池找，如果有直接用，没有就会新创建一个常量“123”赋给str1。</p><p>String str2 = new String（“123”）：至少会创建一个对象，最多创建两个对象。</p><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>《阿里巴巴Java开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</p><p>（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p><h2 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别"></a>BIO,NIO,AIO 有什么区别</h2><p><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p><p><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p><p><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><h2 id="Java中的异常体系"><a href="#Java中的异常体系" class="headerlink" title="Java中的异常体系"></a>Java中的异常体系</h2><p>Java中的所有异常都来自顶级父类Throwable。</p><p>Throwable下有两个子类Exception和Error。</p><p>Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行。</p><p>Exception不会导致程序停止，又分为两个部分RunTimeException运行时异常和CheckedException检查异常。</p><p>RunTimeException常常发生在程序运行过程中，会导致程序当前线程执行失败。CheckedException常常发生在程序编译过程中，会导致程序编译不通过。</p><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><h3 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h3><ul><li><strong>静态编译：</strong> 在编译时确定类型，绑定对象</li><li><strong>动态编译：</strong> 运行时确定类型，绑定对象</li></ul><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</li></ul><h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p><strong>反射是框架设计的灵魂。</strong></p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：</p><ol><li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li><li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li><li>动态配置实例的属性；</li><li>……</li></ol><h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="怎么理解面向对象"><a href="#怎么理解面向对象" class="headerlink" title="怎么理解面向对象"></a>怎么理解面向对象</h2><p>面向对象就是看事物的一种方式，我们可以把任意一个事务看成是一个对象，分析他身上具备的主要开发特征，这个就是面向对象思维；我们在面向对象开发中，是在不断的创建对象，用对象只会对象做事。</p><h3 id="为什么说Java只有值传递？"><a href="#为什么说Java只有值传递？" class="headerlink" title="为什么说Java只有值传递？"></a>为什么说Java只有值传递？</h3><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>值传递：再调用函数的时候将实际参数复制一份，这样在函数中对参数修改不会影响到实际参数。</p><p>引用传递：调用函数时，将实际参数地址直接传递到函数，在函数中对参数的修改会影响到实际参数。</p><p>Java采用的格式按值调用，也就是说方法得到的是所有参数值的一个拷贝，即方法不能修改传递给给他的任何参数变量的内容。</p><p>对于对象，是把对象的引用当作值传递给方法，即将对象的地址拷贝传递给函数。</p><h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><p>重载：同一个方法根据输入数据的不同，做出不同的处理。</p><p>重载可以发生在同一个类中，或者父类和子类之间。方法名必须相同，参数类型、个数、顺序、方法返回值、访问修饰符均可不同。</p><p>重写：当子类继承父类时，输入相同的数据，但是要做出有别于父类的相应，就要覆盖父类方法。</p><p>重写发生在运行期，是子类对父类允许访问的方法实现重新编写。</p><p>重写的注意要点：</p><p>如果父类方法修饰符为private/final/static则子类就不能重写该方法，但是被static修饰的方法能够被再次声明。</p><p>方法的重写要遵循“两同两小一大”</p><p>1、“两同”即方法名，形参列表相同；</p><p>2、“两小”指的是自类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法抛出的异常类更小或相等；</p><p>3、“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等；</p><p>关于返回类型，如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值类型是应用类型，重写时是可以返回该引用类型的子类。</p><p>note：</p><p>Java允许重载任何方法，但是构造方法不能被重写。</p><p>重载不是多态，重写是多态。重载是一种语法规范，与多态无关，与面向对象也无关。</p><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型复制的是指向对象的指针，新旧对象共享内存，此为浅拷贝。</p><p>深拷贝：对基本数据类型进行值传递，对应用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p><h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><p>（1）封装</p><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不逊于外部对象直接访问都对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p><p>（2）继承</p><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性的继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间，提高我们的开发效率。</p><p>note：</p><p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，只是拥有。</p><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p><p>子类可以用自己的方式实现父类的方法（重写）。</p><p>super用于在子类中调用父类的构造方法。</p><p>（3）多态</p><p>表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例或接口类型的引用类型变量指向了接口实现类的对象。</p><p>多态的必要条件：</p><p>有类继承或者接口实现；</p><p>子类要重写父类的方法；</p><p>父类的引用指向子类的对象。</p><p>多态的特点：</p><p>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</p><p>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</p><p>多态不能调用“只在子类存在但在父类不存在”的方法；</p><p>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>（1）继承与实现</p><p>继承：如果多个类的某个部分的功能相同，那么可以抽象他出一个类出来，把他们相同部分都放到父类里，让他们都继承这个类。如果继承抽象类，必须重写所有抽象方法。关键字为<strong>extends</strong></p><p>实现：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们实现这个接口，各自实现自己具体的处理方法来处理那个目标。关键字为<strong>implements</strong></p><p>所以继承的根本原因是复用，而实现的根本原因是需要定义一个标准。需要特别注意的是，Java中支持一个类同时实现多个接口，但是不支持同时继承多个类。</p><p>（2）继承与组合</p><p>继承：is-a关系（狗是一个动物）</p><p>组合：has-a关系（狗有一个尾巴）</p><p>组合是通过现有对象进行拼接，组合实现新的更复杂的功能，组合中，对象之间的内部细节不可见，封装性更好。因此我们要多用组合，少用继承。组合比继承更加灵活，也有助于外码维护。</p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>static用于修饰属性、方法、内部类、代码块；</p><p>static修饰的资源属于类级别的，是全体对象实例共享的资源；</p><p>使用static修饰的属性，静态属性是在类加载期间初始化的，使用类名.属性来访问。</p><p>在static内部不能调用非静态方法。</p><p>static不能修饰抽象方法、局部变量。</p><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><p>1、抽象类可以存在普通成员函数，而接口中只能存在public abstract方法。</p><p>2、抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。</p><p>3、抽象类只能继承一个，接口可以实现多个。</p><p>抽象类设计的目的是代码复用。当不同的类具有某些相同的行为，可以让这些类都派生于一个抽象类，抽象类中实现这些行为一致的方法。这样就避免了所有的子类都实现这些方法，达到代码复用的目的。抽象类不能实例化，因为有些不同行为的方法没有实现，无法执行。</p><p>接口只约束行为的有无，但不对其如何实现进行限制。</p><p>当你关注一个事物的本质时，用抽象类；当关注一个操作时，用接口。</p><p>抽象类is-a（奔驰是一辆车）接口like a（自行车像汽车一样跑）</p><h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程：进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的，系统运行一个程序即是一个进程从创建到运行再到消亡的过程。</p><p>线程：线程是划分成更小的运行单位。一个进程在执行过程中可以产生多个线程。一个进程下的多个线程共享进程的堆和方法区资源，每个线程有独立的程序计数器、虚拟机栈和本地方法栈。</p><h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>进程和线程最大不同在于基本上各个进程是相互独立的，而各个线程不一定，同一个进程中的线程可能会互相影响。</p><p>线程执行开销小，多个线程同时运行可以减少线程上下文切换的开销，但不利于资源的管理和保护。线程是程序执行的最小单位，进程是操作系统分配资源的最小单位。多线程也可能会带来内存泄漏、死锁、线程不安全等问题。</p><h2 id="程序计数器为什么是私有的？"><a href="#程序计数器为什么是私有的？" class="headerlink" title="程序计数器为什么是私有的？"></a>程序计数器为什么是私有的？</h2><p>为了线程切换后可以恢复到正确的执行位置，程序计数器存储的是下一条指令所在单元的地址。</p><h2 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h2><p>为了保证线程中局部变量不被别的线程访问到。</p><h2 id="堆和方法区的作用"><a href="#堆和方法区的作用" class="headerlink" title="堆和方法区的作用"></a>堆和方法区的作用</h2><p>堆和方法区是所有线程的共享资源，其中堆是进程中最大的一块内存，用于存放新创建的对象，方法区用于存放已经被加载的类信息、常量、静态变量等数据。</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发：同一时间段，有多个任务都在执行（单位时间内不一定同时执行）。</p><p>并行：单位时间内，有多个任务在同时执行。</p><h2 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h2><p>当代互联网发展趋势：现在系统经常要求百万级并发量甚至千万级并发量，而多线程并发编程正是开发高并发系统的基础。</p><p>CPU发展趋势：现在CPU多核CPU，多线程可以让多个CPU核心被利用，提高了CPU利用率。</p><h2 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h2><p>内存泄漏、死锁、线程不安全。</p><h2 id="一个线程两次调用start-方法会出现什么情况？"><a href="#一个线程两次调用start-方法会出现什么情况？" class="headerlink" title="一个线程两次调用start()方法会出现什么情况？"></a>一个线程两次调用start()方法会出现什么情况？</h2><p>在第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的。</p><h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><p>new：初始状态，线程被构建，到那时还没有调用start（）方法。</p><p>runnable：运行状态，jvm将操作系统中的就绪状态和运行状态统称为运行中。</p><p>blocked：阻塞状态，表示线程阻塞于锁。</p><p>waiting：等待状态，表示线程进入等待状态，表示该线程需要等待其他显存做出一些特定动作。</p><p>time_wating：可以在指定时间自行返回。</p><p>terminated：终止状态，当前线程执行完毕。</p><p>线程创建后处于new状态，调用start（）方法后开始运行，此时处于ready状态，得到了CPU时间片就处于running状态。</p><p>当线程执行wait（）方法后，进入wating状态，需要依靠其他线程通知才能回到运行状态。time_wating状态相当于在wating状态基础上增加了超时限制，当时间到达后会回到runnable状态。</p><p>当线程需要的某些资源被其他线程占用，此时进入blocked状态，直到抢到这个资源结束。</p><p>线程执行完毕后进入terminated状态。</p><h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h2><p>一个CPU核心在任意时刻只能被一个线程使用，为了让这些线程都可以被有效执行，CPU采取的策略是为每个线程分配时间片并轮转。当一个线程的时间片用完后或被迫暂停后，另一个线程会占用CPU。</p><h2 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h2><p>两个或以上线程相互持有对方需要的资源且不释放，相互等待，造成死锁。</p><p>死锁的四个条件：</p><p>互斥条件：资源在任意时刻只能被一个线程占用。</p><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获取的资源保持不放。</p><p>不剥夺条件：线程获取的资源未使用完之前不能被其他线程强行剥夺。</p><p>循环等待条件：若干进程相互等待对方持有的某些资源，直接形成一种头尾相连的循环等待关系。</p><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>破坏产生死锁的条件即可。</p><p>互斥条件：破坏不了，用锁就是为了资源互斥访问。</p><p>请求与保持条件：一次性申请所有资源；</p><p>不剥夺条件：占用部分资源的线程进一步申请其他资源时，若申请不到先主动释放所占有的资源。</p><p>循环等待条件：按序申请资源，反序释放资源。</p><h2 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h2><p>原子性：提供互斥访问。同一时刻只能有一个线程对数据进行访问（synchronized）</p><p>可见性：一个线程对主内存的修改，可以及时被其他线程看到（synchronized和volatile）</p><h2 id="sleep（）、wait（）、yield（）、join（）"><a href="#sleep（）、wait（）、yield（）、join（）" class="headerlink" title="sleep（）、wait（）、yield（）、join（）"></a>sleep（）、wait（）、yield（）、join（）</h2><h4 id="1、锁池"><a href="#1、锁池" class="headerlink" title="1、锁池"></a>1、锁池</h4><p>所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu分配。</p><h4 id="2、等待池"><a href="#2、等待池" class="headerlink" title="2、等待池"></a>2、等待池</h4><p>当我们调用wait（）方法后，线程会放到等待池中，等待池的线程是不会去竞争同步锁的。只有调用了notify（）或notifyAll（）后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放到线程池，而notifyAll（）是将等待池的所有线程放到锁池。</p><h4 id="3、区别"><a href="#3、区别" class="headerlink" title="3、区别"></a>3、区别</h4><p>sleep是线程的静态方法，wait是Object的方法</p><p>相同点：均可暂停线程的执行。</p><p>不同点：sleep（）没有释放锁，wait（）释放了锁。</p><p>sleep（）用于暂停执行，wait（）用于线程交互。</p><p>sleep（）执行后可以自动苏醒，wait（）只能别的线程唤醒。</p><p>yield（）执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行。</p><p>join（）执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那么线程B会进入到阻塞队列，知道线程A结束或中断线程。</p><h2 id="为什么调用start（）会执行run（），而不直接调用run（）"><a href="#为什么调用start（）会执行run（），而不直接调用run（）" class="headerlink" title="为什么调用start（）会执行run（），而不直接调用run（）"></a>为什么调用start（）会执行run（），而不直接调用run（）</h2><p>创建一个线程后，线程进入新建状态，调用start（）方法启动线程，进入就绪状态，当分配到时间片之后可以开始运行。start（）会执行线程相关工作，然后自动执行run（）方法，这是真正的多线程工作。</p><p>若直接执行run（）方法，会把run（）方法当作一个main线程下的普通方法区执行，并不会在某个线程中区执行，不是多线程工作。</p><h2 id="对守护线程的理解"><a href="#对守护线程的理解" class="headerlink" title="对守护线程的理解"></a>对守护线程的理解</h2><p>守护线程：为所有非守护线程（用户线程）提供服务的线程；任何一个守护线程都是整个JVM中所有非守护线程的保姆。</p><p>举例：GC垃圾回收线程就是一个经典的守护线程，当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。</p><p>应用场景：（1）为其他线程提供服务支持的情况；（2）或者在任何情况下，程序结束时，这个线程必须正常且立即关闭，就可以作为守护线程来使用。</p><h2 id="Threadlocal的原理及使用场景"><a href="#Threadlocal的原理及使用场景" class="headerlink" title="Threadlocal的原理及使用场景"></a>Threadlocal的原理及使用场景</h2><p>使用场景：1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。2、线程间数据隔离。3、进行事务操作，用于存储线程事务信息。4、数据库连接，Session会话管理。</p><p>Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection，在整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现事物的隔离性。Spring框架里面就是用的ThreadLocal来实现这种隔离。</p><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><p>1、继承thread类，一般用于复杂的线程操作要求。提供了更多的api功能。</p><p>（1）创建一个类继承Thread类，重写run（）方法，将所要完成的任务代码写进run（）方法中；</p><p>（2）创建Thread类的子类对象；</p><p>（3）调用该对象的start（）方法，先开启线程再调用run（）方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket =<span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(ticket);</span><br><span class="line">                <span class="keyword">if</span>(ticket&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、实现Runnable接口，一般用于简单的执行一个任务。</p><p>（1）创建一个类并实现Runnable接口</p><p>（2）重写run（）方法，将所要完成的任务代码写进run（）方法中。</p><p>（3）创建实现Runnable接口的类的对象，将该对象当作Thread类的构造方法中的参数传进去。</p><p>（4）使用Thread类的构造方法创建一个对象，调用start（）方法启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread2 mt = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(ticket);</span><br><span class="line">                <span class="keyword">if</span>(ticket&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用线程池</p><p>（1）使用Executors类中的newFixedThreadPool（int num）方法创建一个线程数量为num的线程池。</p><p>（2）调用线程池中的execute（）方法执行由实现Runnable接口创建的线程；</p><p>（3）调用线程池中的shutdown（）方法关闭线程池。</p><h2 id="锁相关知识"><a href="#锁相关知识" class="headerlink" title="锁相关知识"></a>锁相关知识</h2><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平锁：多个线程按照申请锁的顺序来获取锁，先到先得。</p><p>优点：所有线程都能得到资源，不会饿死在队列。</p><p>缺点：吞吐量会下降，除了第一个线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</p><p>非公平锁：多个线程获取锁的顺序并不是按照申请顺序，每个线程获取锁的时候，都会直接尝试获取，获取不到再进等待队列，若是能获取到，就直接获取锁。</p><p>优点：可以减少cpu唤醒线程的开销，提高吞吐率。</p><p>缺点：可能导致队列中线程一直获取不到锁，导致饿死。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>关键字synchronized解决的是多个线程直接的访问资源的同步性，该关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。是非公平锁，可重入锁。</p><p>常用于修饰实例方法、静态方法、代码块。</p><p>synchronized锁升级：无锁，偏向锁，轻量级锁，重量级锁</p><p>初次执行到synchronized代码块的时候，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程不会主动释放偏向锁。当第二次到达同步代码块后，线程会判断此时持有锁的线程是否就是自己，如果是就正常执行，也不用重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁。</p><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即通过CAS算法修改对象头里的锁标志位。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，这种现象叫忙等。如果锁竞争情况严重达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。当后续线程尝试获取锁时，发现被占用的锁时重量级锁，则直接将自己挂起而不是忙等。</p><p>在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>作用1、解决了变量之间在多个线程之间的可见性，该关键字修饰的变量会直接在主内存中进行读写操作。</p><p>作用2、防止JVM指令重排优化，保证代码执行顺序不变。</p><h3 id="ReetrantLock可重入锁"><a href="#ReetrantLock可重入锁" class="headerlink" title="ReetrantLock可重入锁"></a>ReetrantLock可重入锁</h3><p>解释1：某个线程已经获得某个锁，这个线程可以再次获取锁。可重入锁的设计是为了避免死锁。比如递归函数有加锁操作，递归过程中不会阻塞自己。</p><p>解释2：<strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p><p>ReetrantLock默认是非公平锁，当线程获取锁时先通过两次CAS操作去抢锁，没抢到就加入队列。</p><p>公平锁和非公平锁区别：非公平锁在调用lock后，会先调用CAS抢锁，若恰好锁没有被占用，直接获取锁返回。若CAS失败，会和公平锁一样进入tryAcquire方法，在这个方法中，如果发现锁被释放了，非公平锁会直接CAS抢锁，但是公平锁会判断等待队列还有没有线程等待，若是有则继续排队。</p><p>ReentrantLock继承了AQS（AbstractQueuedSynchronized），它是ReentrantLock加锁释放锁的核心。</p><h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><p>1、两者都是可重入锁</p><p>2、synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API（JDK层面）</p><p>3、ReentrantLock 比 synchronized 增加了一些高级功能，主要有等待可中断，可实现公平锁。</p><h3 id="AQS抽象队列同步器"><a href="#AQS抽象队列同步器" class="headerlink" title="AQS抽象队列同步器"></a>AQS抽象队列同步器</h3><p>Java大部分同步类是基于AQS实现的，AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><h3 id="synchronized与volatile"><a href="#synchronized与volatile" class="headerlink" title="synchronized与volatile"></a>synchronized与volatile</h3><p>volatile只能修饰变量，synchronized可以修饰方法和代码块。</p><p>synchronized可能发生阻塞，volatile不会发生阻塞。</p><p>synchronized可以保证数据的可见性和原子性，volatile不能保证原子性。</p><p>synchronized解决的是多个线程之间访问资源的同步性，volatile解决的是多个线程之间的可见性。</p><h3 id="synchronized与lock"><a href="#synchronized与lock" class="headerlink" title="synchronized与lock"></a>synchronized与lock</h3><p>synchronized是java语言的关键字，是内置特性。Lock是一个接口，通过这个接口的实现类可以实现同步访问。</p><p>采用synchronized不需要用户手动释放锁，当代码块执行完毕或者同步异常会自动让线程释放对锁的占用；Lock需要用户手动释放锁，否则可能会导致死锁。</p><p>synchronized可以锁对象、类和代码块，Lock锁的是代码块。</p><p>synchronized是非公平锁，lock可以是公平锁，也可以是非公平锁。</p><h3 id="CAS与synchronized"><a href="#CAS与synchronized" class="headerlink" title="CAS与synchronized"></a>CAS与synchronized</h3><p>CAS适用于写比较少的情况，synchronized适用于写比较多的情况。资源竞争严重，CAS自旋概率大，浪费更多的CPU资源。</p><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>悲观锁：共享资源每次只给一个线程使用，其他线程阻塞，用完之后再把资源让给其他线程。</p><p>乐观锁：总是假设最好的情况，每次去拿数据认为别的线程不会修改数据，所以不会上锁，但是更新的时候会判断再此期间是否有线程去更新这个数据，可以使用版本号机制和CAS算法实现，适用于多读场景。</p><h3 id="实现锁的两种实现方式"><a href="#实现锁的两种实现方式" class="headerlink" title="实现锁的两种实现方式"></a>实现锁的两种实现方式</h3><p>版本号机制</p><p>在数据表中加上一个字段来存数据版本号，当线程要更新数据值的时候，读取数据的同时会读取版本号，提交更新的时候，若读取的version不一致，会重试更新操作，直至更新成功。</p><p>CAS算法（compare and swap 比较和交换）</p><p>在无锁的情况下实现多线程之间的变量同步。</p><p>三个操作数：需要读写的内存值V，旧的预期值A，拟写入的新值B。当且仅当V=A时，用B更新V，否则不会执行任何操作，不断自旋重试。</p><h3 id="乐观锁缺点"><a href="#乐观锁缺点" class="headerlink" title="乐观锁缺点"></a>乐观锁缺点</h3><p>自旋操作长时间不成功会对CPU带来很大的执行开销。CAS只对单个共享变量有效，当操作设计跨多个共享变量时CAS无效。对此Java提供了AtomicReference类，把多个共享变量合并成一个共享变量来操作。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>是一种线程的使用模式。创建若干个可执行线程放入一个容器中，有任务需要处理的时候，会提交到线程池的任务队列，处理完之后的线程不会被销毁，仍在线程池中等待下一个任务。</p><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>降低资源消耗。重复利用已创建线程，避免频繁创建销毁线程，减少资源消耗。</p><p>提高响应速度。当任务到达便可以直接执行，不需要等待线程创建</p><p>提高线程的可管理性。使用线程池可以对线程统一分配、调优和监控。</p><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>可以使用ThreadPoolExecutor类创建线程池，构造函数有七个参数：</p><p>corePoolSize：核心线程数，定义了最少可以同时运行的线程数量，当有新任务时会创建一个线程执行，当线程数量达到限制后，到达的任务进入阻塞队列。</p><p>maximumPoolSize：最大线程数，定义了线程数的线程上限。</p><p>keepAliveTime：定义了等待时间，当线程池中线程数超过核心线程数超过核心线程数，且一个线程的空闲时间达到等待时间，就终止。</p><p>unit：等待时间的单位。</p><p>workQueue：阻塞队列，用于存储等待执行的任务。</p><p>threadFactory：创建线程的工厂。</p><p>handler：拒绝处理任务时的策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以通过execute方法提交任务，线程池的操作：</p><p>如果正在运行的线程数小于corePoolSize，会创建核心线程运行这个任务。</p><p>如果正在运行的线程数量大于或者等于corePoolSize，将任务放入阻塞队列。</p><p>如果阻塞队列满了，且正在运行的线程数小于maximumPoolSize，创建非核心线程运行任务。</p><p>如果阻塞队列满了，且正在运行的线程数大于或等于maximumPoolSize，线程池抛出RehectExecutionException异常。</p><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>调用shutdown或者shutdownNow关闭线程池。前者将线程池状态设置为shutdown，正在执行的任务将继续执行，没有执行任务的线程中断。后者将线程池状态设置stop，中断所有线程。</p><h3 id="线程池五种状态"><a href="#线程池五种状态" class="headerlink" title="线程池五种状态"></a>线程池五种状态</h3><p>running：线程池创建之后的初始状态，这种状态下可以执行任务。</p><p>shutdown：该状态下线程池不再接受新任务，但是会将工作队列中的任务执行结束。</p><p>stop：该状态下线程池不再接受新任务，但是不会处理工作队列中的任务，并且将会</p><p>中断线程。</p><p>tidying：该状态下所有任务都已终止，将会执行terminated（）钩子方法。</p><p>terminated：执行完钩子方法之后。</p><h3 id="执行-execute-方法和-submit-方法的区别"><a href="#执行-execute-方法和-submit-方法的区别" class="headerlink" title="执行 execute()方法和 submit()方法的区别"></a>执行 execute()方法和 submit()方法的区别</h3><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><h3 id="线程池中阻塞队列的作用？为什么是先添加队列还不是先创建最大线程"><a href="#线程池中阻塞队列的作用？为什么是先添加队列还不是先创建最大线程" class="headerlink" title="线程池中阻塞队列的作用？为什么是先添加队列还不是先创建最大线程"></a>线程池中阻塞队列的作用？为什么是先添加队列还不是先创建最大线程</h3><p>1、一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前任务了，阻塞队列通过阻塞可以保住当前想要继续入对的任务。</p><p>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。</p><p>阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时，线程利用阻塞队列的take方法挂起，从而维持核心线程的存活，不至于一直占用cpu资源</p><p>2、在创建新线程的时候，是要获取全局锁的，这个时候其他的就得阻塞，影响了整体效率。所以一般线程数大于核心线程数时可以先把任务积压一下，迟早会干完的。</p><h1 id="Java设计模式总结："><a href="#Java设计模式总结：" class="headerlink" title="Java设计模式总结："></a>Java设计模式总结：</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码：</strong>构造函数是私有的。</p><p><strong>应用实例：</strong></p><ul><li>1、一个班级只有一个班主任。</li><li>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ul><p><strong>优点：</strong></p><ul><li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>2、避免对资源的多重占用（比如写文件操作）。</li></ul><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>使用场景：</strong></p><ul><li><p>1、要求生产唯一序列号。</p></li><li><p>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</p></li><li><p>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="懒汉式，线程不安全（不支持多线程）"><a href="#懒汉式，线程不安全（不支持多线程）" class="headerlink" title="懒汉式，线程不安全（不支持多线程）"></a>懒汉式，线程不安全（不支持多线程）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;          </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();      </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> instance;      </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式，线程安全-效率较低"><a href="#懒汉式，线程安全-效率较低" class="headerlink" title="懒汉式，线程安全(效率较低)"></a>懒汉式，线程安全(效率较低)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;          </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();      </span><br><span class="line">        &#125;      <span class="keyword">return</span> instance;      </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="饿汉式（较常用，但容易产生垃圾对象）"><a href="#饿汉式（较常用，但容易产生垃圾对象）" class="headerlink" title="饿汉式（较常用，但容易产生垃圾对象）"></a>饿汉式（较常用，但容易产生垃圾对象）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> instance;      </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双重校验锁（DCL，即 double-checked locking）"></a>双检锁/双重校验锁（DCL，即 double-checked locking）</h4><p>  <strong>JDK 版本：</strong>JDK1.5 起</p><p>  <strong>是否 Lazy 初始化：</strong>是</p><p>  <strong>是否多线程安全：</strong>是</p><p>  <strong>实现难度：</strong>较复杂</p><p>  <strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>  getInstance() 的性能对应用程序很关键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式（factory-pattern）"><a href="#工厂模式（factory-pattern）" class="headerlink" title="工厂模式（factory pattern）"></a>工厂模式（factory pattern）</h2><p>工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。该模式用于封装和管理对象的创建，是一种创建型模式。本文从一个具体的例子逐步深入分析，来体会三种工厂模式的应用场景和利弊。</p><h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其UML类图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/1419489-20190628144601084-563759643.png" alt=""></p><p>下面我们使用手机生产来讲解该模式：</p><p><strong>Phone类</strong>：手机标准规范类(AbstractProduct)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>MiPhone类</strong>：制造小米手机（Product1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make xiaomi phone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IPhone类</strong>：制造苹果手机（Product2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make iphone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PhoneFactory类</strong>：手机代工厂（Factory）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">(String phoneType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(phoneType.equalsIgnoreCase(<span class="string">&quot;MiPhone&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(phoneType.equalsIgnoreCase(<span class="string">&quot;iPhone&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        PhoneFactory factory = <span class="keyword">new</span> PhoneFactory();</span><br><span class="line">        Phone miPhone = factory.makePhone(<span class="string">&quot;MiPhone&quot;</span>);            <span class="comment">// make xiaomi phone!</span></span><br><span class="line">        IPhone iPhone = (IPhone)factory.makePhone(<span class="string">&quot;iPhone&quot;</span>);    <span class="comment">// make iphone!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-工厂方法模式-Factory-Method"><a href="#2-工厂方法模式-Factory-Method" class="headerlink" title="2. 工厂方法模式(Factory Method)"></a>2. 工厂方法模式(Factory Method)</h3><p>和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，其UML类图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/1419489-20190628154133368-906051111.png" alt=""></p><p>也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。</p><p>接下来继续使用生产手机的例子来讲解该模式。</p><p>其中和产品相关的Phone类、MiPhone类和IPhone类的定义不变。</p><p><strong>AbstractFactory类</strong>：生产不同产品的工厂的抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Phone <span class="title">makePhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>XiaoMiFactory类</strong>：生产小米手机的工厂（ConcreteFactory1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AppleFactory类</strong>：生产苹果手机的工厂（ConcreteFactory2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        AbstractFactory miFactory = <span class="keyword">new</span> XiaoMiFactory();</span><br><span class="line">        AbstractFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">        miFactory.makePhone();            <span class="comment">// make xiaomi phone!</span></span><br><span class="line">        appleFactory.makePhone();        <span class="comment">// make iphone!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p><h2 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h2><p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p><ul><li><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li><li><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</li><li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li></ul><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><h1 id="接口的等幂性"><a href="#接口的等幂性" class="headerlink" title="接口的等幂性"></a>接口的等幂性</h1><h3 id="什么是接口等幂性？"><a href="#什么是接口等幂性？" class="headerlink" title="什么是接口等幂性？"></a>什么是接口等幂性？</h3><p>接口等幂性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生副作用。</p><h3 id="什么情况需要接口等幂性？"><a href="#什么情况需要接口等幂性？" class="headerlink" title="什么情况需要接口等幂性？"></a>什么情况需要接口等幂性？</h3><p>查询操作</p><p>查询操作对于结果不会有更改，查询一次和多次不会有影响，查询操作具有等幂性。</p><p>删除操作</p><p>删除一次和删除多次都是把数据删除，在不考虑返回结果的情况下，删除操作具有幂等性。</p><p>更新操作</p><p>增量修改需要保证幂等性，指定修改具有幂等性。</p><p>新增操作</p><p>新增操作在重复提交的场景下需要保证幂等性。</p><h3 id="如何保证幂等性？"><a href="#如何保证幂等性？" class="headerlink" title="如何保证幂等性？"></a>如何保证幂等性？</h3><p>1、前端按钮实现</p><p>按钮只能点击一次，点击之后显示loading。</p><p>2、后端使用唯一索引</p><p>对业务唯一的字段加上唯一索引，这样当数据重复的时候，插入数据库会报错。</p><h1 id="JVM面试总结"><a href="#JVM面试总结" class="headerlink" title="JVM面试总结"></a>JVM面试总结</h1><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/HsJXU8S4oVtCTM7.png" alt=""></p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E9%9D%A2%E8%AF%95/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt=""></p><p>虚拟机栈：线程私有的。每个方法在执行的时候也会创建一个栈帧，存储了局部变量，操作数，动态链接，方法返回地址。（操作数栈：例如a+b，先从局部变量中压入a和b的值，然后取出这两个值做加法运算，并把结果再压入操作数栈（牵扯一些JVM指令）。动态链接：运行期间把符号引用转化为直接引用。）</p><p>本地方法栈：线程私有的。存放本地方法。本地方法一般是用于操作系统的交互，使用native 修饰。常用的Object 类中的hashcode、wait 、notify、notifyAll 等都是本地方法。是无法用Java语言编写的方法（一般C++或C）。</p><p>程序计数器：线程私有。计数器记录的是虚拟机字节码指令的地址(当前指令的地址)，以便多线程上下文切换后，该线程获得时间片能够得到正确的执行位置。</p><p>堆：线程共享，存对象（Math math = new Math()，虚拟机栈存的是math的内存地址，也就是指针指向堆中的Math对象）（public static User user = new User(); 同理方法区存的静态变量也是指向堆中的User对象）</p><p>方法区：线程共享：用于存储已经被虚拟机加载的类信息，常量，静态变量等。</p><h2 id="类加载器相关"><a href="#类加载器相关" class="headerlink" title="类加载器相关"></a>类加载器相关</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li></ol><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>类加载过程主要分为三部分：加载、链接、初始化，其中链接又分为验证、准备、解析。</p><p>1、加载是指把class字节码文件通过类加载器装载入内存。</p><p>2、验证是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。</p><p>3、准备阶段是为类变量（static）分配内存，赋予初始值。</p><p>4、解析阶段是将常量池内符号引用替换为直接引用的过程。符号引用是指字符串，这个字符串可以唯一性的识别一个方法、变量、类；直接引用可以理解为一个内存地址，或者一个偏移量。</p><p><strong>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</strong></p><p>5、初始化阶段是对类变量的初始化，是执行类构造器的过程，只对static修饰的变量或者语句进行初始化。</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父加载器去完成，比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E9%9D%A2%E8%AF%95/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt=""></p><p>双亲委派模型的好处：</p><p>主要是为了安全性，避免用户自己编写的类动态替换Java的一些核心类，比如String。</p><p>同时也避免了类的重复加载，因为JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加载就是不同的两个类。</p><h3 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h3><p>new关键字</p><p>class类的newInstance</p><p>Constructor的newInstance</p><p>clone</p><p>序列化</p><h2 id="堆内存相关"><a href="#堆内存相关" class="headerlink" title="堆内存相关"></a>堆内存相关</h2><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.png" alt=""></p><p>上图所示的 Eden 区、From Survivor0(“From”) 区、To Survivor1(“To”) 区都属于新生代，Old Memory 区属于老年代。</p><p>1、对象优先在 eden 区分配</p><p>2、大对象直接进入老年代</p><p>3、长期存活的对象将进入老年代</p><p>4、动态对象年龄判定</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次（minor gc）新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p>经过这次 GC 后，Eden 区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次 GC 前的“From”，新的”From”就是上次 GC 前的”To”。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%A0%86%E5%86%85%E5%AD%98.png" alt=""></p><h3 id="如何判断一个对象需要被干掉"><a href="#如何判断一个对象需要被干掉" class="headerlink" title="如何判断一个对象需要被干掉"></a>如何判断一个对象需要被干掉</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88.png" alt=""></p><p>两个基础方法：</p><p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。</p><p>2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如Java，C#等都是靠这招去判定对象是否存活的。</p><p>GC Roots的对象有：</p><p>1、虚拟机栈（栈帧中的本地变量表）中引用的对象</p><p>2、方法区中类静态属性引用的对象</p><p>3、方法区中常量引用的对象</p><p>4、本地方法栈中（Native）引用的对象</p><h2 id="JVM调优相关"><a href="#JVM调优相关" class="headerlink" title="JVM调优相关"></a>JVM调优相关</h2><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>减少full gc次数和时间。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>Arthas：命令：dashboard、thread 8、jad反编译</p><h2 id="垃圾收集相关"><a href="#垃圾收集相关" class="headerlink" title="垃圾收集相关"></a>垃圾收集相关</h2><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>为了提高应用程序的稳定性，选择正确的<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">垃圾收集</a>算法至关重要。</p><p>JVM具有四种类型的<em>GC</em>实现：</p><ul><li>串行垃圾收集器</li><li>并行垃圾收集器</li><li>CMS垃圾收集器</li><li>G1垃圾收集器</li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png" alt=""></p><p>1、标记-清除算法</p><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><p>2、标记-复制算法</p><p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p>3、标记-整理算法</p><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p>4、一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt=""></p><h4 id="1、Serial-收集器"><a href="#1、Serial-收集器" class="headerlink" title="1、Serial 收集器"></a>1、Serial 收集器</h4><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了</p><p>它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/46873026.png" alt=""></p><h4 id="2、ParNew-收集器"><a href="#2、ParNew-收集器" class="headerlink" title="2、ParNew 收集器"></a>2、ParNew 收集器</h4><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/22018368.png" alt=""></p><h4 id="3、Parallel-Scavenge-收集器"><a href="#3、Parallel-Scavenge-收集器" class="headerlink" title="3、Parallel Scavenge 收集器"></a>3、Parallel Scavenge 收集器</h4><p>它看上去几乎和 ParNew 都一样，<strong>Parallel Scavenge </strong>收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</p><h4 id="4、CMS-收集器"><a href="#4、CMS-收集器" class="headerlink" title="4、CMS 收集器"></a>4、CMS 收集器</h4><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt=""></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h4 id="5、G1-收集器"><a href="#5、G1-收集器" class="headerlink" title="5、G1 收集器"></a>5、G1 收集器</h4><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java容器&quot;&gt;&lt;a href=&quot;#Java容器&quot; class=&quot;headerlink&quot; title=&quot;Java容器&quot;&gt;&lt;/a&gt;Java容器&lt;/h1&gt;&lt;h3 id=&quot;List和Set的区别&quot;&gt;&lt;a href=&quot;#List和Set的区别&quot; class=&quot;header</summary>
      
    
    
    
    <category term="面试" scheme="https://xiaobubuya.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="集合" scheme="https://xiaobubuya.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
    <category term="JVM" scheme="https://xiaobubuya.github.io/tags/JVM/"/>
    
    <category term="Java基础" scheme="https://xiaobubuya.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="多线程" scheme="https://xiaobubuya.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://xiaobubuya.github.io/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://xiaobubuya.github.io/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2021-05-06T12:55:34.000Z</published>
    <updated>2021-06-02T01:36:18.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="30张图带你彻底理解红黑树"><a href="#30张图带你彻底理解红黑树" class="headerlink" title="30张图带你彻底理解红黑树"></a>30张图带你彻底理解红黑树</h1><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p><strong>当在10亿数据进行不到30次比较就能查找到目标时，不禁感叹编程之魅力！人类之伟大呀！ —— 学红黑树有感。</strong></p><p>终于，在学习了几天的红黑树相关的知识后，我想把我所学所想和所感分享给大家。红黑树是一种比较难的数据结构，要完全搞懂非常耗时耗力，红黑树怎么自平衡？什么时候需要左旋或右旋？插入和删除破坏了树的平衡后怎么处理？等等一连串的问题在学习前困扰着我。如果你在学习过程中也会存在我的疑问，那么本文对你会有帮助，本文帮助你全面、彻底地理解红黑树！</p><p>本文将通过图文的方式讲解红黑树的知识点，并且不会涉及到任何代码，相信我，在懂得红黑树实现原理前，看代码会一头雾水的，当原理懂了，代码也就按部就班写而已，没任何难度。</p><p>阅读本文你需具备知识点：</p><ul><li>二叉查找树</li><li>完美平衡二叉树</li></ul><p>事不宜迟，让我们进入正题吧。</p><hr><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>红黑树也是二叉查找树，我们知道，二叉查找树这一数据结构并不难，而红黑树之所以难是难在它是自平衡的二叉查找树，在进行插入和删除等可能会破坏树的平衡的操作时，需要重新自处理达到平衡状态。现在在脑海想下怎么实现？是不是太多情景需要考虑了？啧啧，先别急，通过本文的学习后，你会觉得，其实也不过如此而已。好吧，我们先来看下红黑树的定义和一些基本性质。</p><h4 id="红黑树定义和性质"><a href="#红黑树定义和性质" class="headerlink" title="红黑树定义和性质"></a>红黑树定义和性质</h4><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li></ul><p>从性质5又可以推出：</p><ul><li>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ul><p>图1就是一颗简单的红黑树。其中Nil为叶子结点(<strong>2020/01/16补充：图1中的红色结点H和M同样存在叶子子结点，后文的图类似，不再阐明。感谢评论区的同学提醒，带来误解抱歉。</strong>)，并且它是黑色的。(值得提醒注意的是，在Java中，叶子结点是为null的结点。)</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-4996bbfb4017a3b2.png" alt=""></p><p>图1 一颗简单的红黑树</p><p>红黑树并不是一个<em>完美</em>平衡二叉查找树，从图1可以看到，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为<strong>黑色完美平衡</strong>。</p><p>介绍到此，为了后面讲解不至于混淆，我们还需要来约定下红黑树一些结点的叫法，如图2所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-abedf3ecc733ccd5.png" alt=""></p><p>图2 结点叫法约定</p><p>我们把正在处理(遍历)的结点叫做当前结点，如图2中的D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做兄弟结点，父亲的父亲叫做祖父结点。</p><p>前面讲到红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。</p><ul><li><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。</li><li><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。</li><li><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-a95db442f1b47f8a.png" alt=""></p><p>图3 左旋</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-0676a8e2a12e2a0b.png" alt=""></p><p>图4 右旋</p><p>上面所说的旋转结点也即旋转的支点，图4和图5中的P结点。<br>我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。<br><strong>左旋</strong>只影响旋转结点和其<strong>右子树</strong>的结构，把右子树的结点往左子树挪了。<br><strong>右旋</strong>只影响旋转结点和其<strong>左子树</strong>的结构，把左子树的结点往右子树挪了。</p><p>所以旋转操作是<strong>局部</strong>的。另外可以看出旋转能保持红黑树平衡的一些端详了：当一边子树的结点少了，那么向另外一边子树“借”一些结点；当一边子树的结点多了，那么向另外一边子树“租”一些结点。</p><p>但要保持红黑树的性质，结点不能乱挪，还得靠变色了。怎么变？具体情景又不同变法，后面会具体讲到，现在只需要记住<strong>红黑树总是通过旋转和变色达到自平衡</strong>。</p><p>balabala了这么多，相信你对红黑树有一定印象了，那么现在来考考你：</p><p><strong><em>思考题1：黑结点可以同时包含一个红子结点和一个黑子结点吗？\</em></strong> (答案见文末)</p><p>接下来先讲解红黑树的查找热热身。</p><hr><h4 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h4><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p><ol><li>从根结点开始查找，把根结点设置为当前结点；</li><li>若当前结点为空，返回null；</li><li>若当前结点不为空，用当前结点的key跟查找key作比较；</li><li>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</li></ol><p>如图5所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-07b47eb3722981e6.png" alt=""></p><p>图5 二叉树查找流程图</p><p>非常简单，但简单不代表它效率不好。正由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为O(2lgN)，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性，而这背后的付出，红黑树的插入操作功不可没～</p><hr><h4 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h4><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：</p><ol><li>从根结点开始查找；</li><li>若根结点为空，那么插入结点作为根结点，结束。</li><li>若根结点不为空，那么把根结点作为当前结点；</li><li>若当前结点为null，返回当前结点的父结点，结束。</li><li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</li></ol><p>如图6所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-7521866b50683a24.png" alt=""></p><p>图6 红黑树插入位置查找</p><p>ok，插入位置已经找到，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是<strong>红色</strong>。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><p>所有插入情景如图7所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-fa2b78271263d2c8.png" alt=""></p><p>图7 红黑树插入情景</p><p>嗯，插入情景很多呢，8种插入情景！但情景1、2和3的处理很简单，而情景4.2和情景4.3只是方向反转而已，懂得了一种情景就能推出另外一种情景，所以总体来看，并不复杂，后续我们将一个一个情景来看，把它彻底搞懂。</p><p>另外，根据二叉树的性质，<strong>除了情景2，所有插入操作都是在叶子结点进行的</strong>。这点应该不难理解，因为查找插入位置时，我们就是在找子结点为空的父结点的。</p><p>在开始每个情景的讲解前，我们还是先来约定下，如图8所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-9ac3d6b69ef7ead3.png" alt=""></p><p>图8 插入操作结点的叫法约定</p><p>图8的字母并不代表结点Key的大小。I表示插入结点，P表示插入结点的父结点，S表示插入结点的叔叔结点，PP表示插入结点的祖父结点。</p><p>好了，下面让我们一个一个来分析每个插入的情景以其处理。</p><h5 id="插入情景1：红黑树为空树"><a href="#插入情景1：红黑树为空树" class="headerlink" title="插入情景1：红黑树为空树"></a>插入情景1：红黑树为空树</h5><p>最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。</p><p><strong>处理：把插入结点作为根结点，并把结点设置为黑色</strong>。</p><h5 id="插入情景2：插入结点的Key已存在"><a href="#插入情景2：插入结点的Key已存在" class="headerlink" title="插入情景2：插入结点的Key已存在"></a>插入情景2：插入结点的Key已存在</h5><p>插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。</p><p><strong>处理：</strong></p><ul><li><strong>把I设为当前结点的颜色</strong></li><li><strong>更新当前结点的值为插入结点的值</strong></li></ul><h5 id="插入情景3：插入结点的父结点为黑结点"><a href="#插入情景3：插入结点的父结点为黑结点" class="headerlink" title="插入情景3：插入结点的父结点为黑结点"></a>插入情景3：插入结点的父结点为黑结点</h5><p>由于插入的结点是红色的，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p><p><strong>处理：直接插入</strong>。</p><h5 id="插入情景4：插入结点的父结点为红结点"><a href="#插入情景4：插入结点的父结点为红结点" class="headerlink" title="插入情景4：插入结点的父结点为红结点"></a>插入情景4：插入结点的父结点为红结点</h5><p>再次回想下红黑树的性质2：根结点是黑色。<strong>如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点</strong>。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。</p><p>情景4又分为很多子情景，下面将进入重点部分，各位看官请留神了。</p><p><strong>插入情景4.1：叔叔结点存在并且为红结点</strong><br>从红黑树性质4可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。如图9和图10所示。</p><p><strong>处理：</strong></p><ul><li><strong>将P和S设置为黑色</strong></li><li><strong>将PP设置为红色</strong></li><li><strong>把PP设置为当前插入结点</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-9f2c746bf0769f49.png" alt=""></p><p>图9 插入情景4.1_1</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-5374ea3c2956b441.png" alt=""></p><p>图10 插入情景4.1_2</p><p>可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。</p><p>试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。<strong>这也是唯一一种会增加红黑树黑色结点层数的插入情景</strong>。</p><p>我们还可以总结出另外一个经验：<strong>红黑树的生长是自底向上的</strong>。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。</p><p><strong>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点</strong><br>单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。</p><p>前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。</p><p><strong>插入情景4.2.1：插入结点是其父结点的左子结点</strong><br><strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行右旋</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-ab4097b750826870.png" alt=""></p><p>图11 插入情景4.2.1</p><p>由图11可得，左边两个红结点，右边不存在，那么一边一个刚刚好，并且因为为红色，肯定不会破坏树的平衡。</p><p>咦，可以把P设为红色，I和PP设为黑色吗？答案是可以！看过《算法：第4版》的同学可能知道，书中讲解的就是把P设为红色，I和PP设为黑色。但把P设为红色，显然又会出现情景4.1的情况，需要自底向上处理，做多了无谓的操作，既然能自己消化就不要麻烦祖辈们啦～</p><p><strong>插入情景4.2.2：插入结点是其父结点的右子结点</strong><br>这种情景显然可以转换为情景4.2.1，如图12所示，不做过多说明了。</p><p><strong>处理：</strong></p><ul><li><strong>对P进行左旋</strong></li><li><strong>把P设置为插入结点，得到情景4.2.1</strong></li><li><strong>进行情景4.2.1的处理</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-fbfc4f299941cb8b.png" alt=""></p><p>图12 插入情景4.2.2</p><p><strong>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点</strong><br>该情景对应情景4.2，只是方向反转，不做过多说明了，直接看图。</p><p><strong>插入情景4.3.1：插入结点是其父结点的右子结点</strong><br><strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行左旋</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-2bc24a78b68dae51.png" alt=""></p><p>图13 插入情景4.3.1</p><p><strong>插入情景4.3.2：插入结点是其父结点的左子结点</strong><br><strong>处理：</strong></p><ul><li><strong>对P进行右旋</strong></li><li><strong>把P设置为插入结点，得到情景4.3.1</strong></li><li><strong>进行情景4.3.1的处理</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-ee1a9027ddcc210a.png" alt=""></p><p>图14 插入情景4.3.2</p><p>好了，讲完插入的所有情景了。可能又同学会想：上面的情景举例的都是第一次插入而不包含自底向上处理的情况，那么上面所说的情景都适合自底向上的情况吗？答案是肯定的。理由很简单，但每棵子树都能自平衡，那么整棵树最终总是平衡的。好吧，在出个习题，请大家拿出笔和纸画下试试（请务必动手画下，加深印象）：</p><p><strong><em>习题1：请画出图15的插入自平衡处理过程。\</em></strong>（答案见文末）</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-28186be7e43be254.png" alt=""></p><p>图15 习题1</p><hr><h4 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h4><p>红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。但稳住，胜利的曙光就在前面了！</p><p>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。</p><p>二叉树删除结点找替代结点有3种情情景：</p><ul><li>情景1：若删除结点无子结点，直接删除</li><li>情景2：若删除结点只有一个子结点，用子结点替换删除结点</li><li>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</li></ul><p>补充说明下，情景3的后继结点是大于删除结点的最小结点，也是删除结点的右子树种最左结点。那么可以拿前继结点（删除结点的左子树最右结点）替代吗？可以的。但习惯上大多都是拿后继结点来替代，后文的讲解也是用后继结点来替代。另外告诉大家一种找前继和后继结点的直观的方法（不知为何没人提过，大家都知道？）：<strong>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点</strong>。如图16所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-dc4f0ab5d111ff96.png" alt=""></p><p>图16 二叉树投射x轴后有序</p><p>接下来，讲一个重要的思路：<strong>删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！</strong>话很苍白，我们看图17。在不看键值对的情况下，图17的红黑树最终结果是删除了Q所在位置的结点！这种思路非常重要，大大简化了后文讲解红黑树删除的情景！</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-f45799daa674d0ad.png" alt=""></p><p>图17 删除结点换位思路</p><p>基于此，上面所说的3种二叉树的删除情景可以相互转换并且最终都是转换为情景1！</p><ul><li>情景2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1。（对于红黑树来说，根据性质5.1，只存在一个子结点的结点肯定在树末了）</li><li>情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1。</li></ul><p>二叉树删除结点情景关系图如图18所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-a48550e315b3b132.png" alt=""></p><p>图18 二叉树删除情景转换</p><p>综上所述，<strong>删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。</strong>有了这结论，我们讨论的删除红黑树的情景就少了很多，因为我们只考虑删除树末结点的情景了。</p><p>同样的，我们也是先来总体看下删除操作的所有情景，如图19所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-edaf96e55f08c198.png" alt=""></p><p>图19 红黑树删除情景</p><p>哈哈，是的，即使简化了还是有9种情景！但跟插入操作一样，存在左右对称的情景，只是方向变了，没有本质区别。同样的，我们还是来约定下，如图20所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-db3468a5977ad998.png" alt=""></p><p>图20 删除操作结点的叫法约定</p><p>图20的字母并不代表结点Key的大小。R表示替代结点，P表示替代结点的父结点，S表示替代结点的兄弟结点，SL表示兄弟结点的左子结点，SR表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色。</p><p>值得特别提醒的是，<strong>R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。</strong></p><p>万事具备，我们进入最后的也是最难的讲解。</p><h5 id="删除情景1：替换结点是红色结点"><a href="#删除情景1：替换结点是红色结点" class="headerlink" title="删除情景1：替换结点是红色结点"></a>删除情景1：替换结点是红色结点</h5><p>我们把替换结点换到了删除结点的位置时，由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。</p><p><strong>处理：颜色变为删除结点的颜色</strong></p><h5 id="删除情景2：替换结点是黑结点"><a href="#删除情景2：替换结点是黑结点" class="headerlink" title="删除情景2：替换结点是黑结点"></a>删除情景2：替换结点是黑结点</h5><p>当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。</p><p><strong>删除情景2.1：替换结点是其父结点的左子结点</strong><br><strong>删除情景2.1.1：替换结点的兄弟结点是红结点</strong><br>若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，不会有其他子情景，我们按图21处理，得到删除情景2.1.2.3（后续讲解，这里先记住，此时R仍然是替代结点，它的新的兄弟结点SL和兄弟结点的子结点都是黑色）。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行左旋，得到情景2.1.2.3</strong></li><li><strong>进行情景2.1.2.3的处理</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-1e4c3388491b588f.png" alt=""></p><p>图21 删除情景2.1.1</p><p><strong>删除情景2.1.2：替换结点的兄弟结点是黑结点</strong><br>当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定（如果也不考虑自底向上的情况，子结点非红即为叶子结点Nil，Nil结点为黑结点），此时又得考虑多种子情景。</p><p><strong>删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色</strong><br>即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又又红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。如图22所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对P进行左旋</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-7eea721cbb855876.png" alt=""></p><p>图22 删除情景2.1.2.1</p><p>平衡后的图怎么不满足红黑树的性质？前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。另外图2.1.2.1是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。如果是自底向上处理的情况，同样，每棵子树都保持平衡状态，最终整棵树肯定是平衡的。后续的情景同理，不做过多说明了。</p><p><strong>删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点</strong><br>兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1。图如23所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对S进行右旋，得到情景2.1.2.1</strong></li><li><strong>进行情景2.1.2.1的处理</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-dc29605ce9889973.png" alt=""></p><p>图23 删除情景2.1.2.2</p><p><strong>删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br>好了，此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。但为什么需要把兄弟结点设为红色呢？显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-75293515d8d87024.png" alt=""></p><p>图24 情景2.1.2.3</p><p><strong>删除情景2.2：替换结点是其父结点的右子结点</strong><br>好啦，右边的操作也是方向相反，不做过多说明了，相信理解了删除情景2.1后，肯定可以理解2.2。</p><p><strong>删除情景2.2.1：替换结点的兄弟结点是红结点</strong><br>处理：</p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行右旋，得到情景2.2.2.3</strong></li><li><strong>进行情景2.2.2.3的处理</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-387664c771b21f1b.png" alt=""></p><p>图25 删除情景2.2.1</p><p><strong>删除情景2.2.2：替换结点的兄弟结点是黑结点</strong><br><strong>删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色</strong><br><strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对P进行右旋</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-b1ea52c823ce0b0b.png" alt=""></p><p>图26 删除情景2.2.2.1</p><p><strong>删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点</strong><br><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对S进行左旋，得到情景2.2.2.1</strong></li><li><strong>进行情景2.2.2.1的处理</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-edcb4ea6ac87e342.png" alt=""></p><p>图27 删除情景2.2.2.2</p><p><strong>删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-6559c4cccf3df81c.png" alt=""></p><p>图28 删除情景2.2.2.3</p><p>综上，红黑树删除后自平衡的处理可以总结为：</p><ol><li>自己能搞定的自消化（情景1）</li><li>自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）</li><li>兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）</li></ol><p>哈哈，是不是跟现实中很像，当我们有困难时，首先先自己解决，自己无力了总兄弟姐妹帮忙，如果连兄弟姐妹都帮不上，再去找远方的亲戚了。这里记忆应该会好记点～</p><p>最后再做个习题加深理解（请不熟悉的同学务必动手画下）：</p><p><em>*</em>习题2：请画出图29的删除自平衡处理过程。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-d3231b6890ab76a3.png" alt=""></p><p>习题2</p><hr><hr><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>耗时良久，终于写完了～自己加深了红黑树的理解的同时，也希望能帮助大家。如果你之前没学习过红黑树，看完这篇文章后可能还存在很多疑问，如果有疑问可以在评论区写出来，我会尽自己所能解答。另外给大家推荐一个支持红黑树在线生成的网站，来做各种情景梳理很有帮助：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsandbox.runjs.cn%2Fshow%2F2nngvn8w">在线生成红黑树</a>。（删除操作那个把替代结点看作删除结点思路就是我自己在用这个网站时自己顿悟的，我觉得这样讲解更容易理解。）</p><p>少了代码是不是觉得有点空虚？哈哈，后续我会写关于Java和HashMap和TreeMap的文章，里面都有红黑树相关的知识。相信看了这篇文章后，再去看Java和HashMap和TreeMap的源码绝对没难度！</p><p>最后来看下思考题和习题的答案吧。</p><hr><h4 id="思考题和习题答案"><a href="#思考题和习题答案" class="headerlink" title="思考题和习题答案"></a>思考题和习题答案</h4><p><strong><em>思考题1：黑结点可以同时包含一个红子结点和一个黑子结点吗？\</em></strong><br>答：可以。如下图的F结点：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-3e64f9f3481b209d.png" alt=""></p><p><strong><em>习题1：请画出图15的插入自平衡处理过程。\</em></strong><br>答：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-f4c0891c264a2243.png" alt=""></p><p><strong><em>习题2：请画出图29的删除自平衡处理过程。\</em></strong><br>答：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/2392382-b037e4c29cbffc4d.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;30张图带你彻底理解红黑树&quot;&gt;&lt;a href=&quot;#30张图带你彻底理解红黑树&quot; class=&quot;headerlink&quot; title=&quot;30张图带你彻底理解红黑树&quot;&gt;&lt;/a&gt;30张图带你彻底理解红黑树&lt;/h1&gt;&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot;</summary>
      
    
    
    
    <category term="学习" scheme="https://xiaobubuya.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://xiaobubuya.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见问题</title>
    <link href="https://xiaobubuya.github.io/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://xiaobubuya.github.io/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-06T12:55:19.000Z</published>
    <updated>2021-06-02T01:36:49.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL小记录"><a href="#MySQL小记录" class="headerlink" title="MySQL小记录"></a>MySQL小记录</h1><h2 id="局部性原理："><a href="#局部性原理：" class="headerlink" title="局部性原理："></a>局部性原理：</h2><p>程序和数据的访问都有聚集成群的倾向，在一个时间段内，仅使用其中一小部分（称空间局部性），或者访问过的程序代码和数据，很快又被访问的可能性很大（称时间局部性）</p><p>磁盘预读（预读的长度一般为页（page）的整数倍）</p><p>页是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页大小通常为4k），主存和磁盘以页为单位交换数据。</p><h2 id="hash表的索引格式"><a href="#hash表的索引格式" class="headerlink" title="hash表的索引格式"></a>hash表的索引格式</h2><p>缺点：1、利用hash存储的话需要将所有的数据文件添加到内存，比较耗费内存空间</p><p>2、如果所有的查询都是等值查询，那么hash确实很快，但是在企业或者实际工作环境中范围查找的数据更多，而不是等值查询，因此hash就不太合适了</p><h2 id="二叉树的索引格式"><a href="#二叉树的索引格式" class="headerlink" title="二叉树的索引格式"></a>二叉树的索引格式</h2><p>缺点：无论是二叉树还是红黑树，都会应为树的深度过深而造成io次数变多，影响数据读取的效率。</p><h2 id="创建索引命令："><a href="#创建索引命令：" class="headerlink" title="创建索引命令："></a>创建索引命令：</h2><p>alter table tableName add index indexName(name(3));</p><p>唯一索引，unique</p><h2 id="回表（二阶索引或辅助索引时）"><a href="#回表（二阶索引或辅助索引时）" class="headerlink" title="回表（二阶索引或辅助索引时）"></a>回表（二阶索引或辅助索引时）</h2><p>索引覆盖(第一个触发回表第二个不用)</p><p>select *from table where name = ?</p><p>select  id from table where name = ?</p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>select * from table where name=? and age=?</p><p>数据存储磁盘，mysql有自己的服务，mysql服务要跟磁盘发生交互，没有索引下推，先从存储引擎中拉取数据（根据name筛选的数据）再根据age进行数据的筛选。有索引下推：会在拉取数据的时候直接根据name，age来获取数据。</p><h2 id="最左匹配（和组合索引一起使用）"><a href="#最左匹配（和组合索引一起使用）" class="headerlink" title="最左匹配（和组合索引一起使用）"></a>最左匹配（和组合索引一起使用）</h2><p>组合索引：name,age</p><p>(name,age) 1,2,4会走索引</p><p>(1)where name =? and age=?</p><p>(2)where name=?</p><p>(3)where age=?</p><p>(4)where age=? and name=?</p><p>sql优化器</p><h2 id="删除和插入数据："><a href="#删除和插入数据：" class="headerlink" title="删除和插入数据："></a>删除和插入数据：</h2><p>1、先创建临时表，将数据导入临时表</p><p>2、把原始表删除</p><p>3、修改临时表的名字</p><p>给当前表加一个Share锁，不会创建临时文件的资源消耗，还是在源文件中但是此时如果有人发起DML操作，很明显数据会不一致，所以添加share锁，读取时没有问题但是DML会有问题。</p><h2 id="索引失效的点："><a href="#索引失效的点：" class="headerlink" title="索引失效的点："></a>索引失效的点：</h2><p>1、匹配列前缀：匹配某一列的值的开头部分</p><p>select * from staffs where name like ‘%J%’;</p><p>select * from staffs where name like ‘J%’;</p><p>2、组合索引中间有范围索引，后面的索引直接失效</p><p>1.有or必全有索引;<br>2.复合索引未用左列字段;<br>3.like以%开头;<br>4.需要类型转换;<br>5.where中索引列有运算;<br>6.where中索引列使用了函数;<br>7.如果mysql觉得全表扫描更快时（数据少）;</p><h1 id="关系型数据库与非关系型数据库"><a href="#关系型数据库与非关系型数据库" class="headerlink" title="关系型数据库与非关系型数据库"></a>关系型数据库与非关系型数据库</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>关系型数据就是依据关系模型来创建的数据库。关系模型就是一对一，一对多，多对多等关系模型。（mysql，oracle，sql server）</p><p>关系型数据库优点：易于维护；使用方便</p><p>缺点：读写性能较差，表结构固定，灵活性欠佳，硬盘IO是高并发读写的瓶颈。</p><p>非关系模型是基于非关系模型的数据库，非关系模型有列模型，键值对模型，文档模型等。(redis， Hbase)</p><p>优点：格式灵活，速度快。</p><p>缺点：不提供sql支持；不支持事务。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据都存在叶子节点，非叶子节点不保存数据只负责查找。</p><p>叶子节点有顺序，之间相互有连接。</p><p>插入删除操作会破坏平衡树的平衡，因此需要对数进行分裂、合并和旋转等操作来维护平衡性。</p><h3 id="InnoDB的B-Tree索引"><a href="#InnoDB的B-Tree索引" class="headerlink" title="InnoDB的B+Tree索引"></a>InnoDB的B+Tree索引</h3><p>分为主索引和辅助索引。主索引的叶子节点data域记录着完整数据记录，这种索引成为聚簇索引，一个表只有一个聚簇索引；辅助索引（非聚簇索引）的叶子节点data域记录着主键的值，使用辅助索引查到主键值，再去主索引中查找完整数据。</p><blockquote><p>优势：</p><p>1、查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高。</p><p>2、聚簇索引对于范围查找效率很高，因为其数据是按照大小排列的。</p><p>3、聚簇索引适合用在排序的场合，非聚簇索引不合适。</p><p>劣势：</p><p>1、维护索引很昂贵，特别是插入新行或者主键被更新导致要分页的时候。</p><p>2、表使用UUID（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能比全表扫描更慢，所以建议使用int的auto_increment所为主键。</p><p>3、如果主键比较大的话，那辅助索引会变得更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用更多的物理空间</p></blockquote><p>InnoDB中一定有主键，主键一定是聚簇索引，不手动设置、则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的隐藏id来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。</p><p>MyISM使用的是非聚簇索引，没有聚簇索引，非聚簇索引的两颗B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键索引无需访问主键的索引树。</p><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><p>哈希索引能以O(1)时间进行查找，但是失去了有序性。InnoDB存储引擎支持自适应Hash，当某个索引值被使用的非常频繁时会在B+Tree索引之上再创建一个hash索引，使B+Tree索引具有hash索引的一些优点。</p><h2 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h2><p>查询更快，占用空间更小</p><p>1、适合索引的列是出现在where子句中的列，或者连接字句中指定的列。</p><p>2、基数较小的表，索引效果较差，没有必要在此列建立索引。</p><p>3、使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间。</p><p>4、不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。</p><p>5、定义有外键的数据列一定要建立索引。</p><p>6、更新频繁字段不适合创建索引。</p><p>7、若是不能有效区分数据的列不适合做索引列（如性别）</p><p>8、尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。</p><p>9、对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p><p>10、对于定义为text、image和bit的数据类型的列不要建立索引。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><p>原子性：事务是最小的执行单位，一个事务中所有操作要么全部完成，要么全部关部不完成，不会结束于中间某个环节。</p><p>一致性：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的。</p><p>隔离性:  并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。</p><p>持久性: 一个事务被提交之后，它对数据库中的数据改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p><h2 id="事务特性如何实现："><a href="#事务特性如何实现：" class="headerlink" title="事务特性如何实现："></a>事务特性如何实现：</h2><p>原子性：回滚日志（undo log），mysql每条记录执行时记录一条相反的操作，可以通过回滚回到前一个状态的值。</p><p>隔离性:  锁机制，MVCC来保证隔离性</p><p>持久性: (redo log) mysql执行操作时先写入redo log，再更新内存和磁盘，出现意外后通过redo log恢复。</p><blockquote><p>InnoDB redo log 写盘，InnoDB事务进入prepare状态。</p><p>如果前面prepare成功，bin log写盘，再继续将事务日志持久化到bin log，如果持久化成功，那么InnoDB事务则进入commit状态（在redo log里面写一个commit记录）</p><p>redo log的刷盘会在系统空闲时进行</p></blockquote><p>一致性：保证了事物的原子性，隔离性和持久性才能保证一致性。</p><h2 id="多个事务同时执行带来的问题"><a href="#多个事务同时执行带来的问题" class="headerlink" title="多个事务同时执行带来的问题"></a>多个事务同时执行带来的问题</h2><p>脏读： 读到其他事务未提交的数据；</p><p>不可重复读: 同一个事务中前后读取的记录内容不一致；</p><p>幻读： 前后读取的记录数量不一致；</p><p>为了解决这些问题提出了隔离级别。</p><h2 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h2><p>MySQL默认隔离级别时可重复读，解决了脏读和不可重复读。幻读指的是在一个事务内，同一select语句在不同时间执行，得到不同的结果，会发生幻读</p><p>实例：在可重复隔离级别下：select发现某记录不存在，准备插入，但执行insert发现存在，无法插入。</p><p>解决幻读的方式：MVCC+间隙锁。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>读未提交：一个事务还没提交，他做的变更能被其他事务看到。</p><p>读已提交：一个事务提交后他做的变更才能被其他事务看到。</p><p>可重复读（MySQL默认级别）：一个事务执行过程中看到的数据，跟这个事务在启动时看到的数据是一致的（有幻读问题）。</p><p>串行化: 对于同一行记录，写会加写锁，读会加读锁，当出现锁冲突，后访问事务必须等前一个事务执行完毕才能继续执行。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制，实现对数据库的并发控制。只有读已提交和可重复读支持MVCC。具体来说，同一条记录在系统中可以存在多个版本，对于select利用快照读会访问版本链中的记录，这就使得其他事务可以修改这条记录并记录到版本链中。实现了读-写并发执行。</p><h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><p>当前读是记录的最新版本，读取时还要保证其他事务不能修改当前记录，会对读取的记录加锁。</p><p>快照读是不加锁的非阻塞读，提高并发性能，读到的不一定是最新数据。</p><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><h1 id="是预编译处理、是占位符，-是字符串替换、是拼接符"><a href="#是预编译处理、是占位符，-是字符串替换、是拼接符" class="headerlink" title="{}是预编译处理、是占位符，${}是字符串替换、是拼接符"></a>{}是预编译处理、是占位符，${}是字符串替换、是拼接符</h1><p>Mybatis在处理#{}时，会将sql中的#{}替换为？，调用PreparedStatement来赋值</p><p>Mybatis在处理${}时，会将sql中的${}替换为变量的值，调用Statement来赋值</p><h1 id="变量替换实在DBMS中、变量替换后，-对应的变量自动加上单引号"><a href="#变量替换实在DBMS中、变量替换后，-对应的变量自动加上单引号" class="headerlink" title="{}变量替换实在DBMS中、变量替换后，#{}对应的变量自动加上单引号"></a>{}变量替换实在DBMS中、变量替换后，#{}对应的变量自动加上单引号</h1><p>${}的变量替换是在DBMS外，变量替换后，${}对应的变量不会加上引号</p><p>使用#{}可以有效的防止SQL注入，提高系统安全性</p><h1 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h1><h2 id="主从读写隔离"><a href="#主从读写隔离" class="headerlink" title="主从读写隔离"></a>主从读写隔离</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20210507185339111.png" alt=""></p><p>步骤：</p><p>1、首先从库在连接到主节点时会创建一个IO线程，用以请求主库更新的binlog，并把接收到的binlog信息写入一个叫做relay log的日志文件</p><p>2、主库也会创建一个log dump线程发送binlog给从库；</p><p>3、同时从库还创建一个SQL线程读取relay log中的内容，并且在从库中更新，从而实现主从一致性，这是一种比较常见的主从复制方式。</p><h2 id="MySQL的慢查询"><a href="#MySQL的慢查询" class="headerlink" title="MySQL的慢查询"></a>MySQL的慢查询</h2><p>全名是<strong>慢查询日志</strong>，是MySQL提供的一种日志记录，用来记录在MySQL中<strong>响应时间超过阀值</strong>的语句。<strong>如果不是调优需要的话，一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。</p><p>1、开启查询缓存</p><p>2、EXPLAIN</p><p>3、只需要一条数据时用LIMIT 1</p><p>4、为搜索字段建索引</p><p>5、避免SELECT *</p><p>6、尽可能的使用NOT NULL</p><h2 id="一个select的过程"><a href="#一个select的过程" class="headerlink" title="一个select的过程"></a>一个select的过程</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720210511145957.png" alt=""></p><h1 id="存储引擎的使用"><a href="#存储引擎的使用" class="headerlink" title="存储引擎的使用"></a>存储引擎的使用</h1><p>表的存储方式，不同的存储引擎会有不同存储方式。</p><h2 id="什么是存储引擎"><a href="#什么是存储引擎" class="headerlink" title="什么是存储引擎"></a>什么是存储引擎</h2><p>存储引擎这个名字只有在MySQL存在（Oracle中有对应的机制，叫存储方式）</p><p>MySQL支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式</p><p>每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。</p><h2 id="常见的存储引擎"><a href="#常见的存储引擎" class="headerlink" title="常见的存储引擎"></a>常见的存储引擎</h2><h3 id="1、MyISAM存储引擎（这种存储引擎不支持事务）"><a href="#1、MyISAM存储引擎（这种存储引擎不支持事务）" class="headerlink" title="1、MyISAM存储引擎（这种存储引擎不支持事务）"></a>1、MyISAM存储引擎（这种存储引擎不支持事务）</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93/4299" alt=""></p><p>优点：是MySQL是MySQL最常用的存储引擎，但不是默认的，这种引擎</p><p>使用三个文件存储</p><p>格式文件 - 存储表结构的定义(.frm)</p><p>数据文件 - 存储表行的内容(.MYD)</p><p>索引文件 -  存储表上索引（.MYI）</p><p>灵活的AUTO_INCREMENT字段处理</p><p>可被转换为压缩、只读表来节省空间</p><p>缺点：</p><h3 id="2、InnoB存储引擎"><a href="#2、InnoB存储引擎" class="headerlink" title="2、InnoB存储引擎"></a>2、InnoB存储引擎</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93/4348" alt=""></p><p>InnoDB存储是MySQL的缺省引擎</p><p>优点：支持事务、行级锁、外键等。这种存储引擎数据的安全得到保障。</p><p>它管理的表具有下列主要特征：</p><p>表的结构存储在以.frm文件中</p><p>数据存储在tablesspace这样的表空间中(逻辑概念)，无法被压缩，无法被转换成只读</p><p>提供了一组用来记录事务性活动的日志文件</p><p>在MySQL服务器崩溃后提供自动恢复</p><p>多版本（MVCC）和行级锁定</p><p>支持外键及引用的完整性，包括级联删除和更新</p><p>级联删除：支持删除父级时，也同时删除子级</p><p>缺点：重量级存储引擎</p><h3 id="3、MEMORY存储引擎"><a href="#3、MEMORY存储引擎" class="headerlink" title="3、MEMORY存储引擎"></a>3、MEMORY存储引擎</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93/4415" alt=""></p><p>缺点：不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。</p><p>优点：查询速度快。</p><p>以前叫做HEPA引擎</p><h3 id="4、CSV存储引擎"><a href="#4、CSV存储引擎" class="headerlink" title="4、CSV存储引擎"></a>4、CSV存储引擎</h3><p>CSV存储引擎实际上操作维护的是一个标准的CSV文件，因此不支持索引等功能。</p><h1 id="数据库常见面试题—锁"><a href="#数据库常见面试题—锁" class="headerlink" title="数据库常见面试题—锁"></a>数据库常见面试题—锁</h1><h3 id="MyISAM与-InnoDB关于锁方面的区别是什么"><a href="#MyISAM与-InnoDB关于锁方面的区别是什么" class="headerlink" title="MyISAM与 InnoDB关于锁方面的区别是什么"></a>MyISAM与 InnoDB关于锁方面的区别是什么</h3><ul><li>MyIsAM默认用的是表级锁,不支持行级锁</li><li>InnoDB默认用的是行级锁,也支持表级锁</li></ul><h3 id="MyIsAM默认支持的表级锁"><a href="#MyIsAM默认支持的表级锁" class="headerlink" title="MyIsAM默认支持的表级锁"></a>MyIsAM默认支持的表级锁</h3><p><strong>表级锁的含义</strong>： 直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许。</p><p><strong>特点</strong>：开销小，加锁快；不会出现死锁；锁定粒度最大（等级最高），发生锁冲突的概率最高，并发度最低。<br>  有 2 种模式：表共享读锁和表独占写锁。<br>  支持并发插入：支持查询和插入操作并发进行（在表尾并发插入）。<br>  锁调度机制：写锁优先。一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁，MySQL 如何处理呢？答案是写进程先获得锁。</p><p>我们在数据库中模拟并发访问的情况，我们在运行一个查询语句的时候，MySQL会自动给表加上读锁，此时新的update、insert、delete操作将会被锁住。同理，当我们对表数据进行增删改的时候，MySQL会自动给表加上一个表级别的写锁。同时我们可以使用语句手动给数据库加锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock tables slowquerytest read;--给表上读锁，模拟比较慢的读操作</span><br><span class="line">unlock tables;--给表解锁</span><br></pre></td></tr></table></figure><p>然后我们做一个查询操作看看（下图），可以发现当读锁未被释放的时候，是无法进行写操作的</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E9%9D%A2%E8%AF%95/JVM/2019080111264293.png" alt=""></p><p>读锁又称为共享锁，因为在进行范围查询的时候，我们依然可以对表进行查询，不受读锁的控制。</p><p>同理，当上了写锁，必须要等写锁释放了，才能进行读操作。此外写锁不共享！即在写锁进行时，在进行写操作，也需要等待写锁释放。写锁又称排它锁。</p><p>当然我们也可以给读语句上排它锁，即给读语句后面加上for update语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select name from slowquerytest for update</span><br></pre></td></tr></table></figure><h3 id="InnoDB默认用的行级锁"><a href="#InnoDB默认用的行级锁" class="headerlink" title="InnoDB默认用的行级锁"></a>InnoDB默认用的行级锁</h3><p>行级锁的含义： 仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。</p><p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小（等级最低），发生锁冲突的概率最低，并发度也最高。</p><p>此外：InnoDB在SQL语句没有用到索引的时候用的是表级锁</p><p>共享锁和排它锁的兼容性<br>只有在两条查询语句都使用共享锁的时候，两条SQL语句才能兼容（同时查询）</p><h3 id="MyIsAM适合的场景"><a href="#MyIsAM适合的场景" class="headerlink" title="MyIsAM适合的场景"></a>MyIsAM适合的场景</h3><p>频繁执行全表count语句<br>对数据进行增删改的频率不高,査询非常频繁<br>没有事务</p><h3 id="InnoDB适合的场景"><a href="#InnoDB适合的场景" class="headerlink" title="InnoDB适合的场景"></a>InnoDB适合的场景</h3><p>数据增删改查都相当频繁<br>可靠性要求比较高,要求支持事务</p><h3 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h3><ul><li>按锁的粒度划分：可分为表级锁、行级锁、页级锁、纪录锁、间隙锁、临键锁。</li><li>按锁属性划分：可分为共享锁、排它锁。</li><li>按锁的状态分类：子项共享锁、意向排他锁。</li></ul><p>共享锁：又称读锁，当一个事务为数据加上读锁后，其他事务也只能对该数据加读锁，不能加写锁，直到所有的读锁释放后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</p><p>排他锁：又称写锁，当一个事务为数据加上写锁时，其他请求不能再为数据加任何锁，知道该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题。</p><p>表锁：表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；粒度大，加锁简单，容易冲突。</p><p>行锁：行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可以正常访问；粒度小，加锁比表锁麻烦，不易冲突，比表锁支持的并发要高。</p><p>纪录锁：纪录锁也属于行锁中的一种，只不过纪录锁的范围只是表中的一条记录，精准条件命中，并且命中的条件字段是唯一索引。</p><p>页锁：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。</p><p>间隙锁：属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。范围查找并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在重复读的事务级别中。</p><p>临键锁：也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是纪录锁和间隙锁的组合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL小记录&quot;&gt;&lt;a href=&quot;#MySQL小记录&quot; class=&quot;headerlink&quot; title=&quot;MySQL小记录&quot;&gt;&lt;/a&gt;MySQL小记录&lt;/h1&gt;&lt;h2 id=&quot;局部性原理：&quot;&gt;&lt;a href=&quot;#局部性原理：&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="面试" scheme="https://xiaobubuya.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="database" scheme="https://xiaobubuya.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>HashMap相关</title>
    <link href="https://xiaobubuya.github.io/HashMap%E7%9B%B8%E5%85%B3/"/>
    <id>https://xiaobubuya.github.io/HashMap%E7%9B%B8%E5%85%B3/</id>
    <published>2021-05-02T11:12:09.000Z</published>
    <updated>2021-06-02T01:36:01.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap。</p><p>下面针对各个实现类的特点做一些说明：</p><p>(1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><p>(2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><p>(3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p>(4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p><p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p><h2 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现 - 方法"></a>功能实现 - 方法</h2><h3 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1.确定哈希桶数组索引位置"></a><strong>1.确定哈希桶数组索引位置</strong></h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p><p>下面举例说明下，n为table的长度。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/hashmap/20190728105806594.png" alt=""></p><h3 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a><strong>2. 分析HashMap的put方法</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/hashmap/2019072810592539.png" alt=""></p><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><h3 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h3><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p><h2 id="JDK1-8的提升"><a href="#JDK1-8的提升" class="headerlink" title="JDK1.8的提升"></a>JDK1.8的提升</h2><p>在JDK1.6，JDK1.7中，HashMap采用位桶+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><p>首先有一个每个元素都是链表（可能表述不准确）的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。</p><pre><code> 当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中</code></pre><p>即HashMap的原理图是：<br><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/hashmap/20160605101246837" alt=""></p><h2 id="源码中的数据域"><a href="#源码中的数据域" class="headerlink" title="源码中的数据域"></a>源码中的数据域</h2><p>加载因子（默认0.75）：为什么需要使用加载因子，为什么需要扩容呢？因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（当然最新版本使用了红黑树后会改进很多），扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率</p><p>HashMap本来是以空间换时间，所以填充比没必要太大。但是填充比太小又会导致空间浪费。如果关注内存，填充比可以稍大，如果主要关注查找性能，填充比可以稍小。</p><h2 id="存取机制"><a href="#存取机制" class="headerlink" title="存取机制"></a>存取机制</h2><p>get(key)方法时获取key的hash值，计算hash&amp;(n-1)得到在链表数组中的位置first=tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可。</p><p>下面简单说下添加键值对put(key,value)的过程：<br>1，判断键值对数组tab[]是否为空或为null，否则以默认大小resize()；<br>2，根据键值key计算hash值得到插入的数组索引i，如果tab[i]==null，直接新建节点添加，否则转入3<br>3，判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可),分别处理</p><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16），如果Node[]数组中的元素达到（填充比*Node.length）重新调整HashMap大小 变为原来2倍大小</p><h2 id="JDK1-8使用红黑树的改进"><a href="#JDK1-8使用红黑树的改进" class="headerlink" title="JDK1.8使用红黑树的改进"></a>JDK1.8使用红黑树的改进</h2><p>在java jdk8中对HashMap的源码进行了优化，在jdk7中，HashMap处理“碰撞”的时候，都是采用链表来存储，当碰撞的结点很多时，查询时间是O（n）。<br>在jdk8中，HashMap处理“碰撞”增加了红黑树这种数据结构，当碰撞结点较少时，采用链表存储，当较大时（&gt;8个），采用红黑树（特点是查询时间是O（logn））存储（有一个阀值控制，大于阀值(8个)，将链表存储转换成红黑树存储）</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/hashmap/20160605110353076" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、</summary>
      
    
    
    
    <category term="面试" scheme="https://xiaobubuya.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="集合" scheme="https://xiaobubuya.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot启动原理</title>
    <link href="https://xiaobubuya.github.io/Spring-Boot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://xiaobubuya.github.io/Spring-Boot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</id>
    <published>2021-04-30T07:31:02.000Z</published>
    <updated>2021-06-02T01:40:43.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot启动流程"><a href="#Springboot启动流程" class="headerlink" title="Springboot启动流程"></a>Springboot启动流程</h1><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-51aa162747fcdc3d.png" alt=""></p><p><a href="https://www.processon.com/view/link/59812124e4b0de2518b32b6e">原图链接</a></p><p><strong>总览：</strong></p><p>​    上图为SpringBoot启动结构图，我们发现启动流程主要分为三个部分，第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器，第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块，第三部分是自动化配置模块，该模块作为springboot自动配置核心，在后面的分析中会详细讨论。在下面的启动程序中我们会串联起结构中的主要功能。</p><p><strong>启动：</strong></p><p>每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run()启动整个spring-boot程序，该方法所在类需要使用@SpringBootApplication注解，以及@ImportResource注解(if need)，@SpringBootApplication包括三个注解，功能如下：</p><p>@EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置</p><p>@SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境</p><p>@ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下</p><p>回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成，接下来我们来探讨自动化配置是如何实现。</p><p><strong>自动化配置：</strong></p><p>​    之前的启动结构图中，我们注意到无论是应用初始化还是具体的执行过程，都调用了SpringBoot自动配置模块</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-8f2374a500b07c6d.webp" alt=""></p><p>SpringBoot自动配置模块</p><p>​    该配置模块的主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-71e4d0e8cda64ee7.png" alt=""></p><p>工厂接口与其若干实现类接口名称</p><p>下图有助于我们形象理解自动配置流程</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-95d1af756cee57ad.png" alt=""></p><p>SpringBoot自动化配置关键组件关系图 </p><p>​    mybatis-spring-boot-starter、spring-boot-starter-web等组件的META-INF文件下均含有spring.factories文件，自动配置模块中，SpringFactoriesLoader收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。</p><p>之前我们提到了EnableAutoConfiguration注解，其类图如下</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-577bc78a48cea9ef.png" alt=""></p><p>可以发现其最终实现了ImportSelector(选择器)和BeanClassLoaderAware(bean类加载器中间件)，重点关注一下AutoConfigurationImportSelector的selectImports方法</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-05843dc2de08fefe.png" alt=""></p><p>该方法在springboot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的，不要急我们继续向下分析</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-1acb163dede80c03.png" alt=""></p><p>该方法中的getCandidateConfigurations方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了loadFactoryNames方法，查看该方法</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-0398d3354e6b91d1.png" alt=""></p><p>在上面的代码可以看到自动配置器会跟根据传入的factoryClass.getName()到项目系统路径下所有的spring.factories文件中找到相应的key，从而加载里面的类。我们就选取这个mybatis-spring-boot-autoconfigure下的spring.factories文件</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-84f04d5605c8a185.png" alt=""></p><p>进入org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration中，主要看一下类头</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-d836df5a3ae71c08.png" alt=""></p><p>发现@Spring的Configuration，俨然是一个通过注解标注的springBean，继续向下看，</p><p>@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class})这个注解的意思是：当存在SqlSessionFactory.class, SqlSessionFactoryBean.class这两个类时才解析MybatisAutoConfiguration配置类,否则不解析这一个配置类，make sence，我们需要mybatis为我们返回会话对象，就必须有会话工厂相关类</p><p>@CondtionalOnBean(DataSource.class):只有处理已经被声明为bean的dataSource</p><p>@ConditionalOnMissingBean(MapperFactoryBean.class)这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行（该类源码较长，篇幅限制不全粘贴）</p><p>​    以上配置可以保证sqlSessionFactory、sqlSessionTemplate、dataSource等mybatis所需的组件均可被自动配置，@Configuration注解已经提供了Spring的上下文环境，所以以上组件的配置方式与Spring启动时通过mybatis.xml文件进行配置起到一个效果。通过分析我们可以发现，只要一个基于SpringBoot项目的类路径下存在SqlSessionFactory.class, SqlSessionFactoryBean.class，并且容器中已经注册了dataSourceBean，就可以触发自动化配置，意思说我们只要在maven的项目中加入了mybatis所需要的若干依赖，就可以触发自动配置，但引入mybatis原生依赖的话，每集成一个功能都要去修改其自动化配置类，那就得不到开箱即用的效果了。所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖(mybatis)如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-b616bb63af52b5dd.png" alt=""></p><p>这里是截取的mybatis-spring-boot-starter的源码中pom.xml文件中所有依赖:</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/6912735-eeed64900a5e35c5.png" alt=""></p><p>因为maven依赖的传递性，我们只要依赖starter就可以依赖到所有需要自动配置的类，实现开箱即用的功能。也体现出Springboot简化了Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</p><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h3 id="AOP是什么？"><a href="#AOP是什么？" class="headerlink" title="AOP是什么？"></a>AOP是什么？</h3><p>Spring AOP(Aspect Oriented Programming，面向切面编程)是OOPs(面向对象编程)的补充，它也提供了模块化。与OOP对比，面向切面，传统的OOP开发中的代码逻辑是至上而下的过程中会长生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不会散落在代码的各个地方，造成难以维护，AOP的编程思想就是把业务逻辑和横切的问题进行分离，从而达到解耦的目的，使代码的重用性和开发效率高（目的是重用代码，把公共的代码抽取出来）</p><h3 id="AOP的应用场景有哪些？"><a href="#AOP的应用场景有哪些？" class="headerlink" title="AOP的应用场景有哪些？"></a>AOP的应用场景有哪些？</h3><p>1、日志记录</p><p>2、权限验证</p><p>3、效率检查（个人在代码上，喜欢用注解+切面，实现校验，redis分布式锁等功能）</p><p>4、事务管理（spring 的事务就是用AOP实现的）</p><h3 id="springAop的底层是怎样实现的？"><a href="#springAop的底层是怎样实现的？" class="headerlink" title="springAop的底层是怎样实现的？"></a>springAop的底层是怎样实现的？</h3><p>1、JDK动态代理</p><p>2、CGLIB代理</p><h3 id="是编译时期进行织入，还是运行期进行织入？"><a href="#是编译时期进行织入，还是运行期进行织入？" class="headerlink" title="是编译时期进行织入，还是运行期进行织入？"></a>是编译时期进行织入，还是运行期进行织入？</h3><p>运行期，生成字节码，再加载到虚拟机中，JDK是利用反射原理，CGLIB使用了ASM原理。</p><h3 id="初始化时期织入还是获取对象时织入？"><a href="#初始化时期织入还是获取对象时织入？" class="headerlink" title="初始化时期织入还是获取对象时织入？"></a>初始化时期织入还是获取对象时织入？</h3><p>初始化的时候，已经将目标对象进行代理，放入到spring 容器中</p><h3 id="spring-AOP-默认使用jdk动态代理还是cglib？"><a href="#spring-AOP-默认使用jdk动态代理还是cglib？" class="headerlink" title="spring AOP 默认使用jdk动态代理还是cglib？"></a>spring AOP 默认使用jdk动态代理还是cglib？</h3><p>要看条件，如果实现了接口的类，是使用jdk。如果没实现接口，就使用cglib。</p><h3 id="spring-AOP-和-AspectJ的关系？"><a href="#spring-AOP-和-AspectJ的关系？" class="headerlink" title="spring AOP 和 AspectJ的关系？"></a>spring AOP 和 AspectJ的关系？</h3><p>两者都是为了实现AOP这个目的，而出现的技术，spring aop 参考 AspectJ编程风格</p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="Spring，SpringBoot，SpringMVC的区别"><a href="#Spring，SpringBoot，SpringMVC的区别" class="headerlink" title="Spring，SpringBoot，SpringMVC的区别"></a>Spring，SpringBoot，SpringMVC的区别</h3><p>SpringFramework 最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。</p><p>Spring MVC 提供了一种分离式的方法来开发 Web 应用。</p><p>Spring 和 SpringMVC 的问题在于需要配置大量的参数。Spring Boot 通过一个自动配置和启动的项来目解决这个问题。</p><h3 id="什么是自动配置？"><a href="#什么是自动配置？" class="headerlink" title="什么是自动配置？"></a>什么是自动配置？</h3><p>Spring 查看（CLASSPATH 上可用的框架）已存在的应用程序的配置。在此基础上，Spring Boot 提供了配置应用程序和框架所需要的基本配置。这就是自动配置</p><h3 id="什么是-Spring-Boot-Stater-？"><a href="#什么是-Spring-Boot-Stater-？" class="headerlink" title="什么是 Spring Boot Stater ？"></a>什么是 Spring Boot Stater ？</h3><p>这些依赖项。Spring Boot Starter Web 预先打包了这些依赖项。作为一个开发者，我不需要再担心这些依赖项和它们的兼容版本</p><h3 id="Spring-是如何快速创建产品就绪应用程序的？"><a href="#Spring-是如何快速创建产品就绪应用程序的？" class="headerlink" title="Spring 是如何快速创建产品就绪应用程序的？"></a>Spring 是如何快速创建产品就绪应用程序的？</h3><p>Spring Boot 致力于快速产品就绪应用程序。为此，它提供了一些譬如高速缓存，日志记录，监控和嵌入式服务器等开箱即用的非功能性特征。</p><h3 id="为什么我们需要-spring-boot-maven-plugin"><a href="#为什么我们需要-spring-boot-maven-plugin" class="headerlink" title="为什么我们需要 spring-boot-maven-plugin?"></a>为什么我们需要 spring-boot-maven-plugin?</h3><p>spring-boot-maven-plugin 提供了一些像 jar 一样打包或者运行应用程序的命令。</p><h3 id="如何使用-SpringBoot-自动重装我的应用程序？"><a href="#如何使用-SpringBoot-自动重装我的应用程序？" class="headerlink" title="如何使用 SpringBoot 自动重装我的应用程序？"></a>如何使用 SpringBoot 自动重装我的应用程序？</h3><p>把下面的依赖项添加至你的 Spring Boot Project pom.xml 中</p><h3 id="什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢"><a href="#什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢" class="headerlink" title="什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?"></a>什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?</h3><p>嵌入式服务器就是我们的可执行单元包含服务器的二进制文件（例如，tomcat.jar）。</p><p>当我们创建一个可以部署的应用程序的时候，我们将会把服务器（例如，tomcat）嵌入到可部署的服务器中。你就可以想运行正常 Java 应用程序一样来运行 web 应用程序了。</p><h3 id="谈谈你对IOC的理解"><a href="#谈谈你对IOC的理解" class="headerlink" title="谈谈你对IOC的理解"></a>谈谈你对IOC的理解</h3><p>容器概念、控制反转、依赖注入</p><h4 id="IOC容器："><a href="#IOC容器：" class="headerlink" title="IOC容器："></a>IOC容器：</h4><p>里面存的是各种对象（xml里配置的bean节点、@repository、@service、@controller、@component），项目启动时读取配置文件中的bean节点，根据类名反射创建对象到容器中，同时扫描上述注解的类通过反射对象存入容器。</p><p>代码中需要用到里面的对象时，再通过（autowired、resource等注解）注入。</p><h4 id="控制反转："><a href="#控制反转：" class="headerlink" title="控制反转："></a>控制反转：</h4><p>如果没有引入IOC容器，对象A依赖于对象B，那么对象A在初始化或者运行到某一点时，自己必须主动去创建对象B或者使用已经创建的对象B，无论是创建还是使用对象B，控制权都在自己手上。</p><p>引入IOC容器之后，对象A和对象B失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p><h4 id="依赖注入："><a href="#依赖注入：" class="headerlink" title="依赖注入："></a>依赖注入：</h4><p>依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态的将某种依赖关系注入到对象之中。</p><h3 id="什么是Spring-IOC-容器？"><a href="#什么是Spring-IOC-容器？" class="headerlink" title="什么是Spring IOC 容器？"></a>什么是Spring IOC 容器？</h3><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><h3 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h3><p>IOC 或 依赖注入把应用的代码量降到最低。</p><h3 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h3><p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p><h3 id="请说明一下-Controller和-RestController的区别是什么？"><a href="#请说明一下-Controller和-RestController的区别是什么？" class="headerlink" title="请说明一下@Controller和@RestController的区别是什么？"></a>请说明一下@Controller和@RestController的区别是什么？</h3><p>@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用</p><p>@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。</p><p>@Controller 处理http请求</p><h3 id="Bean生命周期流程图："><a href="#Bean生命周期流程图：" class="headerlink" title="Bean生命周期流程图："></a>Bean生命周期流程图：</h3><p><img src="https://uploadfiles.nowcoder.com/images/20180926/308572_1537967995043_4D7CF33471A392D943F00167D1C86C10" alt=""></p><p>1、实例化bean对象(通过构造方法或者工厂方法)<br>2、设置对象属性(setter等)（依赖注入）<br>3、如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）<br>4、如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身<br>5、将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法<br>6、调用Bean的初始化方法<br>7、将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法<br>8、使用Bean<br>9、容器关闭之前，调用Bean的销毁方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Springboot启动流程&quot;&gt;&lt;a href=&quot;#Springboot启动流程&quot; class=&quot;headerlink&quot; title=&quot;Springboot启动流程&quot;&gt;&lt;/a&gt;Springboot启动流程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.</summary>
      
    
    
    
    <category term="面试" scheme="https://xiaobubuya.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Spring Boot" scheme="https://xiaobubuya.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议三次握手四次挥手</title>
    <link href="https://xiaobubuya.github.io/TCP%E5%8D%8F%E8%AE%AE%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://xiaobubuya.github.io/TCP%E5%8D%8F%E8%AE%AE%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2021-04-26T02:33:05.000Z</published>
    <updated>2021-06-02T01:35:28.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><p><strong>TCP运输连接有三个阶段：连接建立、数据传送、连接释放</strong></p><p>TCP连接过程通常叫做<strong>握手</strong>，握手需要客户端和服务器端交换三个报文，如下图所示</p><p>之所以需要三次握手是因为TCP是可靠传输，三次能够刚好可靠又不多余TCP三次握手与Socket的连接过程是相关联对应的，Socket就是对于TCP/IP的封装么</p><p><strong>客户端有CLOSED、SYN-SEND、ESTABLISHED三种状态</strong></p><p><strong>服务器端有CLOSED、LISTEN、SYN-RCVD、ESTABLISHED四种状态</strong></p><p>服务器会首先创建连接，并且进入监听等待阶段，等待客户端的请求</p><p>当需要发送请求时，浏览器客户端主动打开连接，然后服务器被动打开连接</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/Java/TCP/8309948_1566974042905_FC5D1E4A8542CB51426DC924E8578CD5" alt=""></p><h1 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h1><p>客户端在需要时，向服务器发起请求连接报文，发出后状态从CLOSED转换为SYN-SEND 同步-已发送状态</p><p>服务器一直处于LISTEN状态，接收到请求后，对客户端的请求进行回应，转换为SYN-RCVD，同步-已收到状态</p><p>客户端收到服务器的回应后，状态转换为ESTABLISHED，并且再次向服务器发送确认</p><p>服务器收到客户端的确认之后，服务器也转换为ESTABLISHED状态，完成了连接</p><p><strong>发出消息或者收到消息后状态才会进行切换</strong></p><p><strong>客户端与服务器的握手是一个往复确认的过程</strong></p><p>客户端：发出确认请求，SYN=1，seq=x，你听得到么，我想建立连接（SYN=1），我的序号是x（seq=x）</p><p>服务器：对请求进行确认，也就是回应，我听到了（ACK=1，ack=x+1），你听得到么（SYN=1），我的序号是y（seq=y）</p><p>客户端：对服务器的回应进行确认，我听到了（ACK=1，ack=y+1），我的序号是x+1</p><p>IP数据报经过运输层需要分段发送，所以在TCP的处理过程中，有序号的概念</p><p>比如客户端说我要从666号开始，发送100个数据，服务器说，我是从888号开始回应的</p><p>上面的seq=x 和 seq=y  seq=x+1（上一个seq=x，下一个自然就是seq=x+1了）都是各自的序号</p><p><strong>握手的过程就是SYN seq  ACK ack的来回确认</strong></p><p>SYN ACK是头部的字段，可以理解为标志位，协议中有对他们的值有具体的规定</p><p>ack就是确认号，确认号是期望收到的对方的下一个报文段的第一个数据字节的序号，也就是收到的序号+1否则随便一个，怎么对得上号</p><h1 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h1><p>如果不是三次握手，只有两次</p><p>如果客户端发出请求连接时，报文延时了，于是客户端重新发送了一次连接请求消息</p><p>后来收到了确认，建立了连接，然后完成了数据传输，关闭了连接</p><p>此时，服务器收到了那个迟到的请求消息，此时他应该是个废物了</p><p>但是如果只有两次握手，服务器收到请求就响应建立了连接了</p><p>但是如果是三次，客户端不会再次确认，服务器也就随后知道了这消息有问题，不会建立连接</p><h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><p>连接建立以后就可以进行数据通信传输了</p><p>通信结束后，需要断开连接，断开连接需要四次交互，常被称为四次挥手</p><p>最初状态均为ESTABLISHED，客户端与服务器相互进行数据传送</p><p>下图假设客户端无数据发送，请求断开连接</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/Java/TCP/8309948_1566974066111_035082E832E529B2DFF7F11FE4D076A4" alt=""></p><h1 id="断开过程"><a href="#断开过程" class="headerlink" title="断开过程"></a>断开过程</h1><p>客户端无数据发送时，请求关闭连接，我好了，我想断开连接了（FIN=1）我的序号是u（u就是之前传送过的所有数据的最后一个字节的序号+1）</p><p>此时客户端转变为FIN-WAIT-1状态</p><p>服务器收到客户端的消息后，告诉客户端“好的，我知道了”（ACK=1，ack=u+1），这条消息的序号是v（seq=v ，这是服务器发送消息的序号)</p><p>此时服务器的状态就转换为了CLOSE-WAIT状态</p><p>此时，客户端通往服务器的路就断开了，客户端不能向服务器发送数据</p><p>但是服务器仍旧可以向客户端发送数据，现在是“半关闭”的状态</p><p>当客户端收到来自服务器的确认之后，进入FIN-WAIT-2状态，等待服务器那边说断开连接，等待中。。。。。</p><p>当服务器所有的数据也都完全发送完成了之后，服务器才开始主动告知客户端断开连接（FIN=1，seq=w）</p><p>这中间服务器可能又继续发送了一些数据，可能是v+1 也可能发送了更多，所以设置为w</p><p>并且再次发送确认信息（ACK=1，ack=u+1，因为客户端已经不能发送数据了，服务器期望收到的序号永远都是最后一个序号+1，也就是u+1）</p><p>这时，服务器就进入了LAST-ACK状态，最后确认状态</p><p>客户端收到了服务器的断开连接请求后，也需要给出确认响应（ACK=1，ack=w+1，seq=u+1），然后进入TIME-WAIT状态</p><p>等待两个MSL后，进入关闭状态</p><p>MSL 是Maximum Segment Lifetime英文的缩写“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>服务器最终收到来自客户端的确认信息后，关闭，进入CLOSED状态</p><p><strong>四次挥手也是一个互相确认的过程，你说不玩了，别人答应了，还要等别人都搞好了再告诉你可以走了，你才能走</strong></p><p>客户端：我不想玩了</p><p>服务器：好的我知道了</p><p>服务器：你可以走了</p><p>客户端：好的我走了</p><p>就如同在网吧上网，你点击下机之后，再去网管那边结账结账清楚了之后才彻底结束，而不是你说走就走了，难道你办会员卡了么</p><p>这个过程很好理解，<strong>客户端发出请求后，并不意味着服务器都已经完成响应</strong>，所以当客户端请求断开时，并不能立即断开，还需要等待服务器那边处理妥当，再来通知你的确是可以断开了。消息发出来谁知道别人收没收到，所以还需要一个确认</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP三次握手&quot;&gt;&lt;a href=&quot;#TCP三次握手&quot; class=&quot;headerlink&quot; title=&quot;TCP三次握手&quot;&gt;&lt;/a&gt;TCP三次握手&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;TCP运输连接有三个阶段：连接建立、数据传送、连接释放&lt;/strong&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="学习" scheme="https://xiaobubuya.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://xiaobubuya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>栈、队列、数组的基础用法</title>
    <link href="https://xiaobubuya.github.io/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>https://xiaobubuya.github.io/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</id>
    <published>2021-04-22T01:16:40.000Z</published>
    <updated>2021-06-02T01:35:44.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈的相关操作"><a href="#栈的相关操作" class="headerlink" title="栈的相关操作"></a>栈的相关操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">stack.push(sign * temp);</span><br><span class="line">stack.pop();</span><br><span class="line">stack.peek();</span><br><span class="line">stack.size()</span><br></pre></td></tr></table></figure><h1 id="队列的相关操作"><a href="#队列的相关操作" class="headerlink" title="队列的相关操作"></a>队列的相关操作</h1><h2 id="优先队列相关操作"><a href="#优先队列相关操作" class="headerlink" title="优先队列相关操作"></a>优先队列相关操作</h2><p>初始化：PriorityQueue<Long> heap = new PriorityQueue<Long>();<br>出队： heap.poll();<br>入队： heap.offer(next);<br>默认出队的是最小数，想变成出最大数的操作：<br>Queue<Integer> pq = new PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);<br>遍历队列中元素：<br>for(int num: pq)<br>note：如果出队是Long类型，那么需要先用long类型来接受，之后再强制转换。</p><h2 id="普通队列实例化"><a href="#普通队列实例化" class="headerlink" title="普通队列实例化"></a>普通队列实例化</h2><p>Queue<Integer> que= new ArrayDeque&lt;&gt;();</p><h2 id="双端队列实例化"><a href="#双端队列实例化" class="headerlink" title="双端队列实例化"></a>双端队列实例化</h2><p>Deque<Integer> que= new ArrayDeque&lt;&gt;();<br>双端队列默认的offer是offerLast ，默认的poll是pollFirst。</p><h2 id="ArrayList常用操作"><a href="#ArrayList常用操作" class="headerlink" title="ArrayList常用操作"></a>ArrayList常用操作</h2><p>List<Integer> list=new ArrayList&lt;&gt;();<br>list.add(x)<br>list.contains(x)<br>list.get(index)<br>list.indexOf(x) 返回列表中首次出现的索引。<br>list.lastIndexOf(x) 返回列表中最后一次出现指定元素的索引。<br>list.set(index,x)<br>list.remove()</p><h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/">最小栈</a></h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要做出这道题目，首先要理解栈结构先进后出的性质。</p><p>对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。</p><p>因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。</p><p>那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/dynamicPlanning/%E6%A0%88/155_fig1.gif" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; xStack;</span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        xStack.push(x);</span><br><span class="line">        minStack.push(Math.min(minStack.peek(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></h1><h2 id="双栈"><a href="#双栈" class="headerlink" title="双栈"></a>双栈</h2><h3 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h3><p>维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。</p><p>根据栈先进后出的特性，我们每次往第一个栈里插入元素后，第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素。为了维护队列先进先出的特性，我们引入第二个栈，用第二个栈维护待删除的元素，在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>维护两个栈 stack1 和 stack2，其中 stack1 支持插入操作，stack2 支持删除操作<br>构造方法</p><p>初始化 stack1 和 stack2 为空</p><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>插入元素对应方法 appendTail</p><p>stack1 直接插入元素</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>删除元素对应方法 deleteHead</p><p>如果 stack2 为空，则将 stack1 里的所有元素弹出插入到 stack2 里<br>如果 stack2 仍为空，则返回 -1，否则从 stack2 弹出一个元素并返回</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/dynamicPlanning/%E6%A0%88/jianzhi_9.gif" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack1;</span><br><span class="line">    Deque&lt;Integer&gt; stack2;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果第二个栈为空</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> deleteItem = stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> deleteItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用两个队列实现栈"><a href="#用两个队列实现栈" class="headerlink" title="用两个队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">用两个队列实现栈</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="java中获取数组最大（最小）值的三种方式"><a href="#java中获取数组最大（最小）值的三种方式" class="headerlink" title="java中获取数组最大（最小）值的三种方式"></a>java中获取数组最大（最小）值的三种方式</h1><ol><li><p>先排序，后取最大最小值</p></li><li><p>Collections.min()和Collections.max()方法</p></li><li><p>Arrays.stream(arr).min().getAsInt()和Arrays.stream(arr).max().getAsInt()</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="comment">//排序方式</span></span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">int</span> min=arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> max=arr[len-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Collections类</span></span><br><span class="line">Integer[] integerArray = Arrays.stream(arr).boxed().collect(Collectors.toList()).toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">min = (<span class="keyword">int</span>) Collections.min(Arrays.asList(integerArray));</span><br><span class="line">min = (<span class="keyword">int</span>) Collections.max(Arrays.asList(integerArray));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Array.stream方式</span></span><br><span class="line">min = Arrays.stream(arr).min().getAsInt();</span><br><span class="line">max = Arrays.stream(arr).max().getAsInt();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈的相关操作&quot;&gt;&lt;a href=&quot;#栈的相关操作&quot; class=&quot;headerlink&quot; title=&quot;栈的相关操作&quot;&gt;&lt;/a&gt;栈的相关操作&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="学习" scheme="https://xiaobubuya.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://xiaobubuya.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis工作原理</title>
    <link href="https://xiaobubuya.github.io/Mybatis%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://xiaobubuya.github.io/Mybatis%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2021-04-20T02:40:45.000Z</published>
    <updated>2021-06-02T01:41:20.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Mybatis工作原理图"><a href="#一、Mybatis工作原理图" class="headerlink" title="一、Mybatis工作原理图"></a>一、Mybatis工作原理图</h1><p>mybatis 原理图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/Java/Mybatis/20180624002302854.png" alt=""></p><h1 id="二、工作原理解析"><a href="#二、工作原理解析" class="headerlink" title="二、工作原理解析"></a>二、工作原理解析</h1><p>mybatis应用程序通过SqlSessionFactoryBuilder从mybatis-config.xml配置文件（也可以用Java文件配置的方式，需要添加@Configuration）来构建SqlSessionFactory（SqlSessionFactory是线程安全的）；</p><p>然后，SqlSessionFactory的实例直接开启一个SqlSession，再通过SqlSession实例获得Mapper对象并运行Mapper映射的SQL语句，完成对数据库的CRUD和事务提交，之后关闭SqlSession。</p><p>说明：SqlSession是单线程对象，因为它是非线程安全的，是持久化操作的独享对象，类似jdbc中的Connection，底层就封装了jdbc连接。</p><p>详细流程如下：</p><p>1、加载mybatis全局配置文件（数据源、mapper映射文件等），解析配置文件，MyBatis基于XML配置文件生成Configuration，和一个个MappedStatement（包括了参数映射配置、动态SQL语句、结果映射配置），其对应着<select | update | delete | insert>标签项。</p><p>2、SqlSessionFactoryBuilder通过Configuration对象生成SqlSessionFactory，用来开启SqlSession。</p><p>3、SqlSession对象完成和数据库的交互：<br>a、用户程序调用mybatis接口层api（即Mapper接口中的方法）<br>b、SqlSession通过调用api的Statement ID找到对应的MappedStatement对象<br>c、通过Executor（负责动态SQL的生成和查询缓存的维护）将MappedStatement对象进行解析，sql参数转化、动态sql拼接，生成jdbc Statement对象<br>d、JDBC执行sql。</p><p>e、借助MappedStatement中的结果映射关系，将返回结果转化成HashMap、JavaBean等存储结构并返回。</p><p>mybatis层次图：<br><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/Java/Mybatis/20180625095624918.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Mybatis工作原理图&quot;&gt;&lt;a href=&quot;#一、Mybatis工作原理图&quot; class=&quot;headerlink&quot; title=&quot;一、Mybatis工作原理图&quot;&gt;&lt;/a&gt;一、Mybatis工作原理图&lt;/h1&gt;&lt;p&gt;mybatis 原理图如下所示：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="面试" scheme="https://xiaobubuya.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="database" scheme="https://xiaobubuya.github.io/tags/database/"/>
    
  </entry>
  
</feed>
