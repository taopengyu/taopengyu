<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java面试汇总"><meta name="keywords" content="集合,JVM,Java基础,多线程"><meta name="author" content="xiaobubuya"><meta name="copyright" content="xiaobubuya"><title>Java面试汇总 | xiaobubuyaのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"X2MTDP5JXS","apiKey":"b740a5c5a0afcfdb46cd9dde3f3da169","indexName":"xiaobubuya","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="xiaobubuyaのBlog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">Java容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E5%92%8CSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.1.</span> <span class="toc-text">List和Set的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.2.</span> <span class="toc-text">ArrayList和LinkedList区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#final"><span class="toc-number">2.1.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals%E4%B8%8E"><span class="toc-number">2.2.</span> <span class="toc-text">equals与&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode%EF%BC%88%EF%BC%89%E4%B8%8Eequals%EF%BC%88%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">hashCode（）与equals（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%97%B6%E8%A6%81%E9%87%8D%E5%86%99hashCode%EF%BC%88%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">为什么重写equals时要重写hashCode（）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1"><span class="toc-number">2.3.</span> <span class="toc-text">拆箱和装箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1"><span class="toc-number">2.3.1.</span> <span class="toc-text">自动拆箱和装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.2.</span> <span class="toc-text">触发场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E6%8B%86%E7%AE%B1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.3.</span> <span class="toc-text">自动装拆箱带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.4.</span> <span class="toc-text">Integer缓存机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">Java基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder"><span class="toc-number">2.5.</span> <span class="toc-text">String、StringBuffer、StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%94%9F%E6%88%90%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.5.1.</span> <span class="toc-text">String生成几个对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigDecimal"><span class="toc-number">2.6.</span> <span class="toc-text">BigDecimal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO-NIO-AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text">BIO,NIO,AIO 有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">2.8.</span> <span class="toc-text">Java中的异常体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">2.9.</span> <span class="toc-text">反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="toc-number">2.9.1.</span> <span class="toc-text">什么是反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91"><span class="toc-number">2.9.2.</span> <span class="toc-text">静态编译和动态编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.9.3.</span> <span class="toc-text">反射机制优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.9.4.</span> <span class="toc-text">反射的应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">Java面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">怎么理解面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">为什么说Java只有值传递？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">3.1.2.</span> <span class="toc-text">值传递和引用传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="toc-number">3.1.3.</span> <span class="toc-text">重载与重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.1.4.</span> <span class="toc-text">深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">3.1.5.</span> <span class="toc-text">面向对象三大特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.6.</span> <span class="toc-text">类之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.2.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">接口和抽象类的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">Java多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.2.</span> <span class="toc-text">线程与进程的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">程序计数器为什么是私有的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">虚拟机栈和本地方法栈为什么是私有的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.4.</span> <span class="toc-text">堆和方法区的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">4.5.</span> <span class="toc-text">并发与并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.6.</span> <span class="toc-text">为什么要使用多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">4.7.</span> <span class="toc-text">多线程问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8start-%E6%96%B9%E6%B3%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">4.8.</span> <span class="toc-text">一个线程两次调用start()方法会出现什么情况？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">4.9.</span> <span class="toc-text">线程的生命周期和状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">4.10.</span> <span class="toc-text">什么是上下文切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">4.11.</span> <span class="toc-text">什么是线程死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">4.12.</span> <span class="toc-text">如何避免死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.13.</span> <span class="toc-text">如何保证线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep%EF%BC%88%EF%BC%89%E3%80%81wait%EF%BC%88%EF%BC%89%E3%80%81yield%EF%BC%88%EF%BC%89%E3%80%81join%EF%BC%88%EF%BC%89"><span class="toc-number">4.14.</span> <span class="toc-text">sleep（）、wait（）、yield（）、join（）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%94%81%E6%B1%A0"><span class="toc-number">4.14.0.1.</span> <span class="toc-text">1、锁池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AD%89%E5%BE%85%E6%B1%A0"><span class="toc-number">4.14.0.2.</span> <span class="toc-text">2、等待池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%8C%BA%E5%88%AB"><span class="toc-number">4.14.0.3.</span> <span class="toc-text">3、区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8start%EF%BC%88%EF%BC%89%E4%BC%9A%E6%89%A7%E8%A1%8Crun%EF%BC%88%EF%BC%89%EF%BC%8C%E8%80%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8run%EF%BC%88%EF%BC%89"><span class="toc-number">4.15.</span> <span class="toc-text">为什么调用start（）会执行run（），而不直接调用run（）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.16.</span> <span class="toc-text">对守护线程的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Threadlocal%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.17.</span> <span class="toc-text">Threadlocal的原理及使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">4.18.</span> <span class="toc-text">创建线程的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">4.19.</span> <span class="toc-text">锁相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">4.19.1.</span> <span class="toc-text">公平锁与非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">4.19.2.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">4.19.3.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReetrantLock%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">4.19.4.</span> <span class="toc-text">ReetrantLock可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.19.5.</span> <span class="toc-text">synchronized 和 ReentrantLock 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="toc-number">4.19.6.</span> <span class="toc-text">AQS抽象队列同步器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E4%B8%8Evolatile"><span class="toc-number">4.19.7.</span> <span class="toc-text">synchronized与volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E4%B8%8Elock"><span class="toc-number">4.19.8.</span> <span class="toc-text">synchronized与lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E4%B8%8Esynchronized"><span class="toc-number">4.19.9.</span> <span class="toc-text">CAS与synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">4.19.10.</span> <span class="toc-text">乐观锁与悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%94%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.19.11.</span> <span class="toc-text">实现锁的两种实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%BC%BA%E7%82%B9"><span class="toc-number">4.19.12.</span> <span class="toc-text">乐观锁缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.20.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">4.20.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">4.20.2.</span> <span class="toc-text">线程池的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.20.3.</span> <span class="toc-text">线程池的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.20.4.</span> <span class="toc-text">向线程池提交任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.20.5.</span> <span class="toc-text">关闭线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">4.20.6.</span> <span class="toc-text">线程池五种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-execute-%E6%96%B9%E6%B3%95%E5%92%8C-submit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.20.7.</span> <span class="toc-text">执行 execute()方法和 submit()方法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%88%E6%B7%BB%E5%8A%A0%E9%98%9F%E5%88%97%E8%BF%98%E4%B8%8D%E6%98%AF%E5%85%88%E5%88%9B%E5%BB%BA%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.20.8.</span> <span class="toc-text">线程池中阻塞队列的作用？为什么是先添加队列还不是先创建最大线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">Java设计模式总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">懒汉式，线程不安全（不支持多线程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E6%95%88%E7%8E%87%E8%BE%83%E4%BD%8E"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">懒汉式，线程安全(效率较低)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E8%BE%83%E5%B8%B8%E7%94%A8%EF%BC%8C%E4%BD%86%E5%AE%B9%E6%98%93%E4%BA%A7%E7%94%9F%E5%9E%83%E5%9C%BE%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">5.1.2.3.</span> <span class="toc-text">饿汉式（较常用，但容易产生垃圾对象）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%A3%80%E9%94%81-%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%EF%BC%88DCL%EF%BC%8C%E5%8D%B3-double-checked-locking%EF%BC%89"><span class="toc-number">5.1.2.4.</span> <span class="toc-text">双检锁&#x2F;双重校验锁（DCL，即 double-checked locking）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88factory-pattern%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">工厂模式（factory pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">1. 简单工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Factory-Method"><span class="toc-number">5.2.2.</span> <span class="toc-text">2. 工厂方法模式(Factory Method)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">模板模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC-%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.5.</span> <span class="toc-text">MVC 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.6.</span> <span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.7.</span> <span class="toc-text">适配器模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%AD%89%E5%B9%82%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">接口的等幂性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%E7%AD%89%E5%B9%82%E6%80%A7%EF%BC%9F"><span class="toc-number">6.0.1.</span> <span class="toc-text">什么是接口等幂性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E9%9C%80%E8%A6%81%E6%8E%A5%E5%8F%A3%E7%AD%89%E5%B9%82%E6%80%A7%EF%BC%9F"><span class="toc-number">6.0.2.</span> <span class="toc-text">什么情况需要接口等幂性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%9F"><span class="toc-number">6.0.3.</span> <span class="toc-text">如何保证幂等性？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">JVM面试总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">JVM内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">7.2.</span> <span class="toc-text">类加载器相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.2.1.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">类加载的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">7.2.3.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">7.2.4.</span> <span class="toc-text">对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E5%92%8C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-number">7.2.5.</span> <span class="toc-text">指针碰撞和空闲列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="toc-number">7.3.</span> <span class="toc-text">堆内存相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E8%A2%AB%E5%B9%B2%E6%8E%89"><span class="toc-number">7.3.1.</span> <span class="toc-text">如何判断一个对象需要被干掉</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98%E7%9B%B8%E5%85%B3"><span class="toc-number">7.4.</span> <span class="toc-text">JVM调优相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="toc-number">7.4.1.</span> <span class="toc-text">目的：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">7.4.2.</span> <span class="toc-text">工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9B%B8%E5%85%B3"><span class="toc-number">7.5.</span> <span class="toc-text">垃圾收集相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">7.5.1.</span> <span class="toc-text">垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">7.5.2.</span> <span class="toc-text">垃圾收集算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.5.3.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.5.3.1.</span> <span class="toc-text">1、Serial 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.5.3.2.</span> <span class="toc-text">2、ParNew 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.5.3.3.</span> <span class="toc-text">3、Parallel Scavenge 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.5.3.4.</span> <span class="toc-text">4、CMS 收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.5.3.5.</span> <span class="toc-text">5、G1 收集器</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/img02/%E5%A4%B4%E5%83%8F.jpg"></div><div class="author-info__name text-center">xiaobubuya</div><div class="author-info__description text-center">命数如织，当为磐石</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/xiaobubuya">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">69</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">28</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://xiaobubuya.cn/gallery">Gallery</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://xiaobubuya.cn/slides">Slides</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/img01/jiangnan.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">xiaobubuyaのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Java面试汇总</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">17.4k</span><span class="post-meta__separator">|</span><span>Reading time: 54 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Java容器"><a href="#Java容器" class="headerlink" title="Java容器"></a>Java容器</h1><h3 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h3><p>List：有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出所有元素，再逐一遍历，还可以使用get（int index）获取指定下标的元素。</p>
<p>Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用iterator接口取得所有元素，再逐一遍历各个元素。</p>
<h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h3><p>ArrayList：基于动态数组，连续内存存储，适合下标访问，扩容机制：因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动</p>
<p>LinkedList：基于链表，可以存储在分散的内存中，适合数据插入和删除，不适合查询：需要注意遍历。遍历LinkedList必须使用iterator不能使用for循环，因为for循环体内通过get（i）都要重新遍历，性能消耗大。</p>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>修饰类：表示类不可被继承</p>
<p>修饰方法：表示方法不可被子类覆盖，但是可以重载</p>
<p>修饰变量：表示变量一旦被复制就不可以更改</p>
<h2 id="equals与"><a href="#equals与" class="headerlink" title="equals与=="></a>equals与==</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>对于基本数据类型，==比较的是值是否相等；</p>
<p>对于引用类型来说，==比较的是两者在内存中存放的地址；</p>
<p>对于引用类型来说，如果equals未被重写，对比的是他们的地址是否相等，若被重写（例如String）比较的是地址里的内容。</p>
<p>对于包装类型，equals首先比较的是否为同类型，非同类型直接返回false，同类型再比较值。</p>
<h3 id="hashCode（）与equals（）"><a href="#hashCode（）与equals（）" class="headerlink" title="hashCode（）与equals（）"></a>hashCode（）与equals（）</h3><p>hashCode（）作用是获取哈希码，作用是确认该对象在哈希表中的索引位置。hashCode（）定义在Object类中，即Java中任何类都包含hashCode（）函数。</p>
<h3 id="为什么重写equals时要重写hashCode（）"><a href="#为什么重写equals时要重写hashCode（）" class="headerlink" title="为什么重写equals时要重写hashCode（）"></a>为什么重写equals时要重写hashCode（）</h3><p>两个对象内容完全相同，hashCode不一定相同，此时单重写equals（），可以比较出两个对象相同，但是容器不会认为两者相同；</p>
<p>HashSet或HashMap在添加对象的时候，依然认为这两个对象不等；</p>
<p>重写hashCode函数后，让两个对象内容完全相同的时候，hashCode也相同，这样容器在添加元素的时候，就会认为这两个对象相等了。</p>
<h2 id="拆箱和装箱"><a href="#拆箱和装箱" class="headerlink" title="拆箱和装箱"></a>拆箱和装箱</h2><h3 id="自动拆箱和装箱"><a href="#自动拆箱和装箱" class="headerlink" title="自动拆箱和装箱"></a>自动拆箱和装箱</h3><p>自动装箱通过包装类的valueOf（）方法来实现。自动拆箱通过包装类的xxxValue（）来实现。</p>
<p>好处：方便（不用考虑包装类和基本类型的转换），节约空间（常量池）。</p>
<h3 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h3><p>（1）场景1：基本数据类型放入集合类 —将基本类型自动装箱</p>
<p>（2）场景2：包装类与基本类型进行运算 —先将包装类进行拆箱成基本类型，然后进行比较</p>
<p>（3）场景3：包装类型之间的运算，会被自动拆箱成基本类型进行。</p>
<p>（4）场景5：函数参数与返回值 —这里会自动拆箱装箱为返回的类型。</p>
<h3 id="自动装拆箱带来的问题"><a href="#自动装拆箱带来的问题" class="headerlink" title="自动装拆箱带来的问题"></a>自动装拆箱带来的问题</h3><p>1、==比较问题</p>
<p>在一定范围内可以进行比较，更多的时候还是要用equals</p>
<p>2、空指针问题</p>
<p>初始包装类型对象为null，拆箱会报NPE（NullPointerException）</p>
<p>3、内存浪费</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1000</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">    sum + = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>+操作先拆箱，得到的结果赋值给sum，会进行装箱，会产生大量无用对象造成内存空间浪费，加重了垃圾回收的工作量。</p>
<h3 id="Integer缓存机制"><a href="#Integer缓存机制" class="headerlink" title="Integer缓存机制"></a>Integer缓存机制</h3><p>目的：有助于节省内存、提高性能。</p>
<p>Integer存在常量值，一次性把-128到127之间所有数都初始化缓存了，==比较的是内存地址，当赋值没有超过范围，内存地址都是常量池的地址，超过了最大缓存量后，各自new一个对象，此时地址不一样。</p>
<h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><p>字符型 char （16bit）</p>
<p>布尔型 boolean </p>
<p>整型 byte short int long （8，16，32，64）</p>
<p>浮点型 float double （32，64）</p>
<h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2><p>String是不可变对象，每次对String类型对象更改相当于新生成一个String对象。</p>
<p>StringBuffer线程安全，StringBuilder非线程安全，速度快。这两个类型的对象可以被多次修改，不会产生新的对象。都不允许直接赋空值，但是构造函数可以赋空值。</p>
<h3 id="String生成几个对象"><a href="#String生成几个对象" class="headerlink" title="String生成几个对象"></a>String生成几个对象</h3><p>String str1 = “123”，最少创建0个对象，最多创建1个对象。当我们栈中的str1想用“123”这个常量时，先去方法区中的常量池找，如果有直接用，没有就会新创建一个常量“123”赋给str1。</p>
<p>String str2 = new String（“123”）：至少会创建一个对象，最多创建两个对象。</p>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>《阿里巴巴Java开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</p>
<p>（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p>
<h2 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别"></a>BIO,NIO,AIO 有什么区别</h2><p><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p>
<p><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p>
<p><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<h2 id="Java中的异常体系"><a href="#Java中的异常体系" class="headerlink" title="Java中的异常体系"></a>Java中的异常体系</h2><p>Java中的所有异常都来自顶级父类Throwable。</p>
<p>Throwable下有两个子类Exception和Error。</p>
<p>Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行。</p>
<p>Exception不会导致程序停止，又分为两个部分RunTimeException运行时异常和CheckedException检查异常。</p>
<p>RunTimeException常常发生在程序运行过程中，会导致程序当前线程执行失败。CheckedException常常发生在程序编译过程中，会导致程序编译不通过。</p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p>
<h3 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h3><ul>
<li><strong>静态编译：</strong> 在编译时确定类型，绑定对象</li>
<li><strong>动态编译：</strong> 运行时确定类型，绑定对象</li>
</ul>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul>
<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li><strong>缺点：</strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</li>
</ul>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p><strong>反射是框架设计的灵魂。</strong></p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：</p>
<ol>
<li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li>
<li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li>
<li>动态配置实例的属性；</li>
<li>……</li>
</ol>
<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="怎么理解面向对象"><a href="#怎么理解面向对象" class="headerlink" title="怎么理解面向对象"></a>怎么理解面向对象</h2><p>面向对象就是看事物的一种方式，我们可以把任意一个事务看成是一个对象，分析他身上具备的主要开发特征，这个就是面向对象思维；我们在面向对象开发中，是在不断的创建对象，用对象只会对象做事。</p>
<h3 id="为什么说Java只有值传递？"><a href="#为什么说Java只有值传递？" class="headerlink" title="为什么说Java只有值传递？"></a>为什么说Java只有值传递？</h3><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>值传递：再调用函数的时候将实际参数复制一份，这样在函数中对参数修改不会影响到实际参数。</p>
<p>引用传递：调用函数时，将实际参数地址直接传递到函数，在函数中对参数的修改会影响到实际参数。</p>
<p>Java采用的格式按值调用，也就是说方法得到的是所有参数值的一个拷贝，即方法不能修改传递给给他的任何参数变量的内容。</p>
<p>对于对象，是把对象的引用当作值传递给方法，即将对象的地址拷贝传递给函数。</p>
<h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><p>重载：同一个方法根据输入数据的不同，做出不同的处理。</p>
<p>重载可以发生在同一个类中，或者父类和子类之间。方法名必须相同，参数类型、个数、顺序、方法返回值、访问修饰符均可不同。</p>
<p>重写：当子类继承父类时，输入相同的数据，但是要做出有别于父类的相应，就要覆盖父类方法。</p>
<p>重写发生在运行期，是子类对父类允许访问的方法实现重新编写。</p>
<p>重写的注意要点：</p>
<p>如果父类方法修饰符为private/final/static则子类就不能重写该方法，但是被static修饰的方法能够被再次声明。</p>
<p>方法的重写要遵循“两同两小一大”</p>
<p>1、“两同”即方法名，形参列表相同；</p>
<p>2、“两小”指的是自类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法抛出的异常类更小或相等；</p>
<p>3、“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等；</p>
<p>关于返回类型，如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值类型是应用类型，重写时是可以返回该引用类型的子类。</p>
<p>note：</p>
<p>Java允许重载任何方法，但是构造方法不能被重写。</p>
<p>重载不是多态，重写是多态。重载是一种语法规范，与多态无关，与面向对象也无关。</p>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型复制的是指向对象的指针，新旧对象共享内存，此为浅拷贝。</p>
<p>深拷贝：对基本数据类型进行值传递，对应用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><p>（1）封装</p>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不逊于外部对象直接访问都对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<p>（2）继承</p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性的继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间，提高我们的开发效率。</p>
<p>note：</p>
<p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，只是拥有。</p>
<p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
<p>子类可以用自己的方式实现父类的方法（重写）。</p>
<p>super用于在子类中调用父类的构造方法。</p>
<p>（3）多态</p>
<p>表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例或接口类型的引用类型变量指向了接口实现类的对象。</p>
<p>多态的必要条件：</p>
<p>有类继承或者接口实现；</p>
<p>子类要重写父类的方法；</p>
<p>父类的引用指向子类的对象。</p>
<p>多态的特点：</p>
<p>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</p>
<p>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</p>
<p>多态不能调用“只在子类存在但在父类不存在”的方法；</p>
<p>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</p>
<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>（1）继承与实现</p>
<p>继承：如果多个类的某个部分的功能相同，那么可以抽象他出一个类出来，把他们相同部分都放到父类里，让他们都继承这个类。如果继承抽象类，必须重写所有抽象方法。关键字为<strong>extends</strong></p>
<p>实现：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们实现这个接口，各自实现自己具体的处理方法来处理那个目标。关键字为<strong>implements</strong></p>
<p>所以继承的根本原因是复用，而实现的根本原因是需要定义一个标准。需要特别注意的是，Java中支持一个类同时实现多个接口，但是不支持同时继承多个类。</p>
<p>（2）继承与组合</p>
<p>继承：is-a关系（狗是一个动物）</p>
<p>组合：has-a关系（狗有一个尾巴）</p>
<p>组合是通过现有对象进行拼接，组合实现新的更复杂的功能，组合中，对象之间的内部细节不可见，封装性更好。因此我们要多用组合，少用继承。组合比继承更加灵活，也有助于外码维护。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>static用于修饰属性、方法、内部类、代码块；</p>
<p>static修饰的资源属于类级别的，是全体对象实例共享的资源；</p>
<p>使用static修饰的属性，静态属性是在类加载期间初始化的，使用类名.属性来访问。</p>
<p>在static内部不能调用非静态方法。</p>
<p>static不能修饰抽象方法、局部变量。</p>
<h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><p>1、抽象类可以存在普通成员函数，而接口中只能存在public abstract方法。</p>
<p>2、抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。</p>
<p>3、抽象类只能继承一个，接口可以实现多个。</p>
<p>抽象类设计的目的是代码复用。当不同的类具有某些相同的行为，可以让这些类都派生于一个抽象类，抽象类中实现这些行为一致的方法。这样就避免了所有的子类都实现这些方法，达到代码复用的目的。抽象类不能实例化，因为有些不同行为的方法没有实现，无法执行。</p>
<p>接口只约束行为的有无，但不对其如何实现进行限制。</p>
<p>当你关注一个事物的本质时，用抽象类；当关注一个操作时，用接口。</p>
<p>抽象类is-a（奔驰是一辆车）接口like a（自行车像汽车一样跑）</p>
<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程：进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的，系统运行一个程序即是一个进程从创建到运行再到消亡的过程。</p>
<p>线程：线程是划分成更小的运行单位。一个进程在执行过程中可以产生多个线程。一个进程下的多个线程共享进程的堆和方法区资源，每个线程有独立的程序计数器、虚拟机栈和本地方法栈。</p>
<h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>进程和线程最大不同在于基本上各个进程是相互独立的，而各个线程不一定，同一个进程中的线程可能会互相影响。</p>
<p>线程执行开销小，多个线程同时运行可以减少线程上下文切换的开销，但不利于资源的管理和保护。线程是程序执行的最小单位，进程是操作系统分配资源的最小单位。多线程也可能会带来内存泄漏、死锁、线程不安全等问题。</p>
<h2 id="程序计数器为什么是私有的？"><a href="#程序计数器为什么是私有的？" class="headerlink" title="程序计数器为什么是私有的？"></a>程序计数器为什么是私有的？</h2><p>为了线程切换后可以恢复到正确的执行位置，程序计数器存储的是下一条指令所在单元的地址。</p>
<h2 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h2><p>为了保证线程中局部变量不被别的线程访问到。</p>
<h2 id="堆和方法区的作用"><a href="#堆和方法区的作用" class="headerlink" title="堆和方法区的作用"></a>堆和方法区的作用</h2><p>堆和方法区是所有线程的共享资源，其中堆是进程中最大的一块内存，用于存放新创建的对象，方法区用于存放已经被加载的类信息、常量、静态变量等数据。</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发：同一时间段，有多个任务都在执行（单位时间内不一定同时执行）。</p>
<p>并行：单位时间内，有多个任务在同时执行。</p>
<h2 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h2><p>当代互联网发展趋势：现在系统经常要求百万级并发量甚至千万级并发量，而多线程并发编程正是开发高并发系统的基础。</p>
<p>CPU发展趋势：现在CPU多核CPU，多线程可以让多个CPU核心被利用，提高了CPU利用率。</p>
<h2 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h2><p>内存泄漏、死锁、线程不安全。</p>
<h2 id="一个线程两次调用start-方法会出现什么情况？"><a href="#一个线程两次调用start-方法会出现什么情况？" class="headerlink" title="一个线程两次调用start()方法会出现什么情况？"></a>一个线程两次调用start()方法会出现什么情况？</h2><p>在第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的。</p>
<h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><p>new：初始状态，线程被构建，到那时还没有调用start（）方法。</p>
<p>runnable：运行状态，jvm将操作系统中的就绪状态和运行状态统称为运行中。</p>
<p>blocked：阻塞状态，表示线程阻塞于锁。</p>
<p>waiting：等待状态，表示线程进入等待状态，表示该线程需要等待其他显存做出一些特定动作。</p>
<p>time_wating：可以在指定时间自行返回。</p>
<p>terminated：终止状态，当前线程执行完毕。</p>
<p>线程创建后处于new状态，调用start（）方法后开始运行，此时处于ready状态，得到了CPU时间片就处于running状态。</p>
<p>当线程执行wait（）方法后，进入wating状态，需要依靠其他线程通知才能回到运行状态。time_wating状态相当于在wating状态基础上增加了超时限制，当时间到达后会回到runnable状态。</p>
<p>当线程需要的某些资源被其他线程占用，此时进入blocked状态，直到抢到这个资源结束。</p>
<p>线程执行完毕后进入terminated状态。</p>
<h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h2><p>一个CPU核心在任意时刻只能被一个线程使用，为了让这些线程都可以被有效执行，CPU采取的策略是为每个线程分配时间片并轮转。当一个线程的时间片用完后或被迫暂停后，另一个线程会占用CPU。</p>
<h2 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h2><p>两个或以上线程相互持有对方需要的资源且不释放，相互等待，造成死锁。</p>
<p>死锁的四个条件：</p>
<p>互斥条件：资源在任意时刻只能被一个线程占用。</p>
<p>请求与保持条件：一个进程因请求资源而阻塞时，对已获取的资源保持不放。</p>
<p>不剥夺条件：线程获取的资源未使用完之前不能被其他线程强行剥夺。</p>
<p>循环等待条件：若干进程相互等待对方持有的某些资源，直接形成一种头尾相连的循环等待关系。</p>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>破坏产生死锁的条件即可。</p>
<p>互斥条件：破坏不了，用锁就是为了资源互斥访问。</p>
<p>请求与保持条件：一次性申请所有资源；</p>
<p>不剥夺条件：占用部分资源的线程进一步申请其他资源时，若申请不到先主动释放所占有的资源。</p>
<p>循环等待条件：按序申请资源，反序释放资源。</p>
<h2 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h2><p>原子性：提供互斥访问。同一时刻只能有一个线程对数据进行访问（synchronized）</p>
<p>可见性：一个线程对主内存的修改，可以及时被其他线程看到（synchronized和volatile）</p>
<h2 id="sleep（）、wait（）、yield（）、join（）"><a href="#sleep（）、wait（）、yield（）、join（）" class="headerlink" title="sleep（）、wait（）、yield（）、join（）"></a>sleep（）、wait（）、yield（）、join（）</h2><h4 id="1、锁池"><a href="#1、锁池" class="headerlink" title="1、锁池"></a>1、锁池</h4><p>所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu分配。</p>
<h4 id="2、等待池"><a href="#2、等待池" class="headerlink" title="2、等待池"></a>2、等待池</h4><p>当我们调用wait（）方法后，线程会放到等待池中，等待池的线程是不会去竞争同步锁的。只有调用了notify（）或notifyAll（）后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放到线程池，而notifyAll（）是将等待池的所有线程放到锁池。</p>
<h4 id="3、区别"><a href="#3、区别" class="headerlink" title="3、区别"></a>3、区别</h4><p>sleep是线程的静态方法，wait是Object的方法</p>
<p>相同点：均可暂停线程的执行。</p>
<p>不同点：sleep（）没有释放锁，wait（）释放了锁。</p>
<p>sleep（）用于暂停执行，wait（）用于线程交互。</p>
<p>sleep（）执行后可以自动苏醒，wait（）只能别的线程唤醒。</p>
<p>yield（）执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行。</p>
<p>join（）执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那么线程B会进入到阻塞队列，知道线程A结束或中断线程。</p>
<h2 id="为什么调用start（）会执行run（），而不直接调用run（）"><a href="#为什么调用start（）会执行run（），而不直接调用run（）" class="headerlink" title="为什么调用start（）会执行run（），而不直接调用run（）"></a>为什么调用start（）会执行run（），而不直接调用run（）</h2><p>创建一个线程后，线程进入新建状态，调用start（）方法启动线程，进入就绪状态，当分配到时间片之后可以开始运行。start（）会执行线程相关工作，然后自动执行run（）方法，这是真正的多线程工作。</p>
<p>若直接执行run（）方法，会把run（）方法当作一个main线程下的普通方法区执行，并不会在某个线程中区执行，不是多线程工作。</p>
<h2 id="对守护线程的理解"><a href="#对守护线程的理解" class="headerlink" title="对守护线程的理解"></a>对守护线程的理解</h2><p>守护线程：为所有非守护线程（用户线程）提供服务的线程；任何一个守护线程都是整个JVM中所有非守护线程的保姆。</p>
<p>举例：GC垃圾回收线程就是一个经典的守护线程，当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。</p>
<p>应用场景：（1）为其他线程提供服务支持的情况；（2）或者在任何情况下，程序结束时，这个线程必须正常且立即关闭，就可以作为守护线程来使用。</p>
<h2 id="Threadlocal的原理及使用场景"><a href="#Threadlocal的原理及使用场景" class="headerlink" title="Threadlocal的原理及使用场景"></a>Threadlocal的原理及使用场景</h2><p>使用场景：1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。2、线程间数据隔离。3、进行事务操作，用于存储线程事务信息。4、数据库连接，Session会话管理。</p>
<p>Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection，在整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现事物的隔离性。Spring框架里面就是用的ThreadLocal来实现这种隔离。</p>
<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><p>1、继承thread类，一般用于复杂的线程操作要求。提供了更多的api功能。</p>
<p>（1）创建一个类继承Thread类，重写run（）方法，将所要完成的任务代码写进run（）方法中；</p>
<p>（2）创建Thread类的子类对象；</p>
<p>（3）调用该对象的start（）方法，先开启线程再调用run（）方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket =<span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(ticket);</span><br><span class="line">                <span class="keyword">if</span>(ticket&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、实现Runnable接口，一般用于简单的执行一个任务。</p>
<p>（1）创建一个类并实现Runnable接口</p>
<p>（2）重写run（）方法，将所要完成的任务代码写进run（）方法中。</p>
<p>（3）创建实现Runnable接口的类的对象，将该对象当作Thread类的构造方法中的参数传进去。</p>
<p>（4）使用Thread类的构造方法创建一个对象，调用start（）方法启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread2 mt = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(ticket);</span><br><span class="line">                <span class="keyword">if</span>(ticket&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、使用线程池</p>
<p>（1）使用Executors类中的newFixedThreadPool（int num）方法创建一个线程数量为num的线程池。</p>
<p>（2）调用线程池中的execute（）方法执行由实现Runnable接口创建的线程；</p>
<p>（3）调用线程池中的shutdown（）方法关闭线程池。</p>
<h2 id="锁相关知识"><a href="#锁相关知识" class="headerlink" title="锁相关知识"></a>锁相关知识</h2><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平锁：多个线程按照申请锁的顺序来获取锁，先到先得。</p>
<p>优点：所有线程都能得到资源，不会饿死在队列。</p>
<p>缺点：吞吐量会下降，除了第一个线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</p>
<p>非公平锁：多个线程获取锁的顺序并不是按照申请顺序，每个线程获取锁的时候，都会直接尝试获取，获取不到再进等待队列，若是能获取到，就直接获取锁。</p>
<p>优点：可以减少cpu唤醒线程的开销，提高吞吐率。</p>
<p>缺点：可能导致队列中线程一直获取不到锁，导致饿死。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>关键字synchronized解决的是多个线程直接的访问资源的同步性，该关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。是非公平锁，可重入锁。</p>
<p>常用于修饰实例方法、静态方法、代码块。</p>
<p>synchronized锁升级：无锁，偏向锁，轻量级锁，重量级锁</p>
<p>初次执行到synchronized代码块的时候，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程不会主动释放偏向锁。当第二次到达同步代码块后，线程会判断此时持有锁的线程是否就是自己，如果是就正常执行，也不用重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p>
<p>一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁。</p>
<p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即通过CAS算法修改对象头里的锁标志位。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p>
<p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，这种现象叫忙等。如果锁竞争情况严重达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。当后续线程尝试获取锁时，发现被占用的锁时重量级锁，则直接将自己挂起而不是忙等。</p>
<p>在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>作用1、解决了变量之间在多个线程之间的可见性，该关键字修饰的变量会直接在主内存中进行读写操作。</p>
<p>作用2、防止JVM指令重排优化，保证代码执行顺序不变。</p>
<h3 id="ReetrantLock可重入锁"><a href="#ReetrantLock可重入锁" class="headerlink" title="ReetrantLock可重入锁"></a>ReetrantLock可重入锁</h3><p>解释1：某个线程已经获得某个锁，这个线程可以再次获取锁。可重入锁的设计是为了避免死锁。比如递归函数有加锁操作，递归过程中不会阻塞自己。</p>
<p>解释2：<strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<p>ReetrantLock默认是非公平锁，当线程获取锁时先通过两次CAS操作去抢锁，没抢到就加入队列。</p>
<p>公平锁和非公平锁区别：非公平锁在调用lock后，会先调用CAS抢锁，若恰好锁没有被占用，直接获取锁返回。若CAS失败，会和公平锁一样进入tryAcquire方法，在这个方法中，如果发现锁被释放了，非公平锁会直接CAS抢锁，但是公平锁会判断等待队列还有没有线程等待，若是有则继续排队。</p>
<p>ReentrantLock继承了AQS（AbstractQueuedSynchronized），它是ReentrantLock加锁释放锁的核心。</p>
<h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><p>1、两者都是可重入锁</p>
<p>2、synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API（JDK层面）</p>
<p>3、ReentrantLock 比 synchronized 增加了一些高级功能，主要有等待可中断，可实现公平锁。</p>
<h3 id="AQS抽象队列同步器"><a href="#AQS抽象队列同步器" class="headerlink" title="AQS抽象队列同步器"></a>AQS抽象队列同步器</h3><p>Java大部分同步类是基于AQS实现的，AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<h3 id="synchronized与volatile"><a href="#synchronized与volatile" class="headerlink" title="synchronized与volatile"></a>synchronized与volatile</h3><p>volatile只能修饰变量，synchronized可以修饰方法和代码块。</p>
<p>synchronized可能发生阻塞，volatile不会发生阻塞。</p>
<p>synchronized可以保证数据的可见性和原子性，volatile不能保证原子性。</p>
<p>synchronized解决的是多个线程之间访问资源的同步性，volatile解决的是多个线程之间的可见性。</p>
<h3 id="synchronized与lock"><a href="#synchronized与lock" class="headerlink" title="synchronized与lock"></a>synchronized与lock</h3><p>synchronized是java语言的关键字，是内置特性。Lock是一个接口，通过这个接口的实现类可以实现同步访问。</p>
<p>采用synchronized不需要用户手动释放锁，当代码块执行完毕或者同步异常会自动让线程释放对锁的占用；Lock需要用户手动释放锁，否则可能会导致死锁。</p>
<p>synchronized可以锁对象、类和代码块，Lock锁的是代码块。</p>
<p>synchronized是非公平锁，lock可以是公平锁，也可以是非公平锁。</p>
<h3 id="CAS与synchronized"><a href="#CAS与synchronized" class="headerlink" title="CAS与synchronized"></a>CAS与synchronized</h3><p>CAS适用于写比较少的情况，synchronized适用于写比较多的情况。资源竞争严重，CAS自旋概率大，浪费更多的CPU资源。</p>
<h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>悲观锁：共享资源每次只给一个线程使用，其他线程阻塞，用完之后再把资源让给其他线程。</p>
<p>乐观锁：总是假设最好的情况，每次去拿数据认为别的线程不会修改数据，所以不会上锁，但是更新的时候会判断再此期间是否有线程去更新这个数据，可以使用版本号机制和CAS算法实现，适用于多读场景。</p>
<h3 id="实现锁的两种实现方式"><a href="#实现锁的两种实现方式" class="headerlink" title="实现锁的两种实现方式"></a>实现锁的两种实现方式</h3><p>版本号机制</p>
<p>在数据表中加上一个字段来存数据版本号，当线程要更新数据值的时候，读取数据的同时会读取版本号，提交更新的时候，若读取的version不一致，会重试更新操作，直至更新成功。</p>
<p>CAS算法（compare and swap 比较和交换）</p>
<p>在无锁的情况下实现多线程之间的变量同步。</p>
<p>三个操作数：需要读写的内存值V，旧的预期值A，拟写入的新值B。当且仅当V=A时，用B更新V，否则不会执行任何操作，不断自旋重试。</p>
<h3 id="乐观锁缺点"><a href="#乐观锁缺点" class="headerlink" title="乐观锁缺点"></a>乐观锁缺点</h3><p>自旋操作长时间不成功会对CPU带来很大的执行开销。CAS只对单个共享变量有效，当操作设计跨多个共享变量时CAS无效。对此Java提供了AtomicReference类，把多个共享变量合并成一个共享变量来操作。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>是一种线程的使用模式。创建若干个可执行线程放入一个容器中，有任务需要处理的时候，会提交到线程池的任务队列，处理完之后的线程不会被销毁，仍在线程池中等待下一个任务。</p>
<h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>降低资源消耗。重复利用已创建线程，避免频繁创建销毁线程，减少资源消耗。</p>
<p>提高响应速度。当任务到达便可以直接执行，不需要等待线程创建</p>
<p>提高线程的可管理性。使用线程池可以对线程统一分配、调优和监控。</p>
<h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>可以使用ThreadPoolExecutor类创建线程池，构造函数有七个参数：</p>
<p>corePoolSize：核心线程数，定义了最少可以同时运行的线程数量，当有新任务时会创建一个线程执行，当线程数量达到限制后，到达的任务进入阻塞队列。</p>
<p>maximumPoolSize：最大线程数，定义了线程数的线程上限。</p>
<p>keepAliveTime：定义了等待时间，当线程池中线程数超过核心线程数超过核心线程数，且一个线程的空闲时间达到等待时间，就终止。</p>
<p>unit：等待时间的单位。</p>
<p>workQueue：阻塞队列，用于存储等待执行的任务。</p>
<p>threadFactory：创建线程的工厂。</p>
<p>handler：拒绝处理任务时的策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以通过execute方法提交任务，线程池的操作：</p>
<p>如果正在运行的线程数小于corePoolSize，会创建核心线程运行这个任务。</p>
<p>如果正在运行的线程数量大于或者等于corePoolSize，将任务放入阻塞队列。</p>
<p>如果阻塞队列满了，且正在运行的线程数小于maximumPoolSize，创建非核心线程运行任务。</p>
<p>如果阻塞队列满了，且正在运行的线程数大于或等于maximumPoolSize，线程池抛出RehectExecutionException异常。</p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>调用shutdown或者shutdownNow关闭线程池。前者将线程池状态设置为shutdown，正在执行的任务将继续执行，没有执行任务的线程中断。后者将线程池状态设置stop，中断所有线程。</p>
<h3 id="线程池五种状态"><a href="#线程池五种状态" class="headerlink" title="线程池五种状态"></a>线程池五种状态</h3><p>running：线程池创建之后的初始状态，这种状态下可以执行任务。</p>
<p>shutdown：该状态下线程池不再接受新任务，但是会将工作队列中的任务执行结束。</p>
<p>stop：该状态下线程池不再接受新任务，但是不会处理工作队列中的任务，并且将会</p>
<p>中断线程。</p>
<p>tidying：该状态下所有任务都已终止，将会执行terminated（）钩子方法。</p>
<p>terminated：执行完钩子方法之后。</p>
<h3 id="执行-execute-方法和-submit-方法的区别"><a href="#执行-execute-方法和-submit-方法的区别" class="headerlink" title="执行 execute()方法和 submit()方法的区别"></a>执行 execute()方法和 submit()方法的区别</h3><ol>
<li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
<h3 id="线程池中阻塞队列的作用？为什么是先添加队列还不是先创建最大线程"><a href="#线程池中阻塞队列的作用？为什么是先添加队列还不是先创建最大线程" class="headerlink" title="线程池中阻塞队列的作用？为什么是先添加队列还不是先创建最大线程"></a>线程池中阻塞队列的作用？为什么是先添加队列还不是先创建最大线程</h3><p>1、一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前任务了，阻塞队列通过阻塞可以保住当前想要继续入对的任务。</p>
<p>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。</p>
<p>阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时，线程利用阻塞队列的take方法挂起，从而维持核心线程的存活，不至于一直占用cpu资源</p>
<p>2、在创建新线程的时候，是要获取全局锁的，这个时候其他的就得阻塞，影响了整体效率。所以一般线程数大于核心线程数时可以先把任务积压一下，迟早会干完的。</p>
<h1 id="Java设计模式总结："><a href="#Java设计模式总结：" class="headerlink" title="Java设计模式总结："></a>Java设计模式总结：</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p>
<p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p>
<p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p><strong>关键代码：</strong>构造函数是私有的。</p>
<p><strong>应用实例：</strong></p>
<ul>
<li>1、一个班级只有一个班主任。</li>
<li>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li>
<li>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>1、要求生产唯一序列号。</li>
<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="懒汉式，线程不安全（不支持多线程）"><a href="#懒汉式，线程不安全（不支持多线程）" class="headerlink" title="懒汉式，线程不安全（不支持多线程）"></a>懒汉式，线程不安全（不支持多线程）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;          </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();      </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> instance;      </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="懒汉式，线程安全-效率较低"><a href="#懒汉式，线程安全-效率较低" class="headerlink" title="懒汉式，线程安全(效率较低)"></a>懒汉式，线程安全(效率较低)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;          </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();      </span><br><span class="line">        &#125;      <span class="keyword">return</span> instance;      </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="饿汉式（较常用，但容易产生垃圾对象）"><a href="#饿汉式（较常用，但容易产生垃圾对象）" class="headerlink" title="饿汉式（较常用，但容易产生垃圾对象）"></a>饿汉式（较常用，但容易产生垃圾对象）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> instance;      </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双重校验锁（DCL，即 double-checked locking）"></a>双检锁/双重校验锁（DCL，即 double-checked locking）</h4><p><strong>JDK 版本：</strong>JDK1.5 起</p>
<p><strong>是否 Lazy 初始化：</strong>是</p>
<p><strong>是否多线程安全：</strong>是</p>
<p><strong>实现难度：</strong>较复杂</p>
<p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我将重点讲解 getInstance 方法，方法中首先进行了一次 if (singleton == null) 的检查，然后是 synchronized 同步块，然后又是一次 if (singleton == null) 的检查，最后是 singleton = new Singleton() 来生成实例。</p>
<p>我们进行了两次 if (singleton == null) 检查，这就是“双重检查锁”这个名字的由来。这种写法是可以保证线程安全的，假设有两个线程同时到达 synchronized 语句块，那么实例化代码只会由其中先抢到锁的线程执行一次，而后抢到锁的线程会在第二个 if 判断中发现 singleton 不为 null，所以跳过创建实例的语句。再后面的其他线程再来调用 getInstance 方法时，只需判断第一次的 if (singleton == null) ，然后会跳过整个 if 块，直接 return 实例化后的对象。</p>
<p>这种写法的优点是不仅线程安全，而且延迟加载、效率也更高。</p>
<p><strong>为什么要 double-check？</strong></p>
<p>我们先来看第二次的 check，这时你需要考虑这样一种情况，有两个线程同时调用 getInstance 方法，由于 singleton 是空的 ，因此两个线程都可以通过第一重的 if 判断；然后由于锁机制的存在，会有一个线程先进入同步语句，并进入第二重 if 判断 ，而另外的一个线程就会在外面等待。</p>
<p>不过，当第一个线程执行完 new Singleton() 语句后，就会退出 synchronized 保护的区域，这时如果没有第二重 if (singleton == null) 判断的话，那么第二个线程也会创建一个实例，此时就破坏了单例，这肯定是不行的。</p>
<p>而对于第一个 check 而言，如果去掉它，那么所有线程都会串行执行，效率低下，所以两个 check 都是需要保留的。</p>
<p><strong>在双重检查锁模式中为什么需要使用 volatile 关键字?</strong></p>
<p>在java内存模型中，volatile 关键字作用可以是保证可见性或者禁止指令重排。这里是因为 singleton = new Singleton() ，它并非是一个原子操作，事实上，在 JVM 中上述语句至少做了以下这 3 件事：</p>
<ul>
<li>第一步是给 singleton 分配内存空间；</li>
<li>第二步开始调用 Singleton 的构造函数等，来初始化 singleton；</li>
<li>第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。</li>
</ul>
<p>这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第 2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。</p>
<p>如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错，详细流程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@thired/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1735488-20200425183747250-500195538.png" alt=""></p>
<p>线程 1 首先执行新建实例的第一步，也就是分配单例对象的内存空间，由于线程 1 被重排序，所以执行了新建实例的第三步，也就是把 singleton 指向之前分配出来的内存地址，在这第三步执行之后，singleton 对象便不再是 null。</p>
<p>这时线程 2 进入 getInstance 方法，判断 singleton 对象不是 null，紧接着线程 2 就返回 singleton 对象并使用，由于没有初始化，所以报错了。最后，线程 1 “姗姗来迟”，才开始执行新建实例的第二步——初始化对象，可是这时的初始化已经晚了，因为前面已经报错了。</p>
<p>使用了 volatile 之后，相当于是表明了该字段的更新可能是在其他线程中发生的，因此应确保在读取另一个线程写入的值时，可以顺利执行接下来所需的操作。在 JDK 5 以及后续版本所使用的 JMM 中，在使用了 volatile 后，会一定程度禁止相关语句的重排序，从而避免了上述由于重排序所导致的读取到不完整对象的问题的发生。</p>
<h2 id="工厂模式（factory-pattern）"><a href="#工厂模式（factory-pattern）" class="headerlink" title="工厂模式（factory pattern）"></a>工厂模式（factory pattern）</h2><p>工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。该模式用于封装和管理对象的创建，是一种创建型模式。本文从一个具体的例子逐步深入分析，来体会三种工厂模式的应用场景和利弊。</p>
<h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其UML类图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/1419489-20190628144601084-563759643.png" alt=""></p>
<p>下面我们使用手机生产来讲解该模式：</p>
<p><strong>Phone类</strong>：手机标准规范类(AbstractProduct)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>MiPhone类</strong>：制造小米手机（Product1）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make xiaomi phone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IPhone类</strong>：制造苹果手机（Product2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make iphone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PhoneFactory类</strong>：手机代工厂（Factory）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">(String phoneType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(phoneType.equalsIgnoreCase(<span class="string">&quot;MiPhone&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(phoneType.equalsIgnoreCase(<span class="string">&quot;iPhone&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        PhoneFactory factory = <span class="keyword">new</span> PhoneFactory();</span><br><span class="line">        Phone miPhone = factory.makePhone(<span class="string">&quot;MiPhone&quot;</span>);            <span class="comment">// make xiaomi phone!</span></span><br><span class="line">        IPhone iPhone = (IPhone)factory.makePhone(<span class="string">&quot;iPhone&quot;</span>);    <span class="comment">// make iphone!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-工厂方法模式-Factory-Method"><a href="#2-工厂方法模式-Factory-Method" class="headerlink" title="2. 工厂方法模式(Factory Method)"></a>2. 工厂方法模式(Factory Method)</h3><p>和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，其UML类图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/Java%E5%9F%BA%E7%A1%80/1419489-20190628154133368-906051111.png" alt=""></p>
<p>也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。</p>
<p>接下来继续使用生产手机的例子来讲解该模式。</p>
<p>其中和产品相关的Phone类、MiPhone类和IPhone类的定义不变。</p>
<p><strong>AbstractFactory类</strong>：生产不同产品的工厂的抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Phone <span class="title">makePhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>XiaoMiFactory类</strong>：生产小米手机的工厂（ConcreteFactory1）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AppleFactory类</strong>：生产苹果手机的工厂（ConcreteFactory2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        AbstractFactory miFactory = <span class="keyword">new</span> XiaoMiFactory();</span><br><span class="line">        AbstractFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">        miFactory.makePhone();            <span class="comment">// make xiaomi phone!</span></span><br><span class="line">        appleFactory.makePhone();        <span class="comment">// make iphone!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p>
<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
<h2 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h2><p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li>
<li><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</li>
<li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li>
</ul>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
<h1 id="接口的等幂性"><a href="#接口的等幂性" class="headerlink" title="接口的等幂性"></a>接口的等幂性</h1><h3 id="什么是接口等幂性？"><a href="#什么是接口等幂性？" class="headerlink" title="什么是接口等幂性？"></a>什么是接口等幂性？</h3><p>接口等幂性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生副作用。</p>
<h3 id="什么情况需要接口等幂性？"><a href="#什么情况需要接口等幂性？" class="headerlink" title="什么情况需要接口等幂性？"></a>什么情况需要接口等幂性？</h3><p>查询操作</p>
<p>查询操作对于结果不会有更改，查询一次和多次不会有影响，查询操作具有等幂性。</p>
<p>删除操作</p>
<p>删除一次和删除多次都是把数据删除，在不考虑返回结果的情况下，删除操作具有幂等性。</p>
<p>更新操作</p>
<p>增量修改需要保证幂等性，指定修改具有幂等性。</p>
<p>新增操作</p>
<p>新增操作在重复提交的场景下需要保证幂等性。</p>
<h3 id="如何保证幂等性？"><a href="#如何保证幂等性？" class="headerlink" title="如何保证幂等性？"></a>如何保证幂等性？</h3><p>1、前端按钮实现</p>
<p>按钮只能点击一次，点击之后显示loading。</p>
<p>2、后端使用唯一索引</p>
<p>对业务唯一的字段加上唯一索引，这样当数据重复的时候，插入数据库会报错。</p>
<h1 id="JVM面试总结"><a href="#JVM面试总结" class="headerlink" title="JVM面试总结"></a>JVM面试总结</h1><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/jdk%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/HsJXU8S4oVtCTM7.png" alt=""></p>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E9%9D%A2%E8%AF%95/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<p>虚拟机栈：线程私有的。每个方法在执行的时候也会创建一个栈帧，存储了局部变量，操作数，动态链接，方法返回地址。（操作数栈：例如a+b，先从局部变量中压入a和b的值，然后取出这两个值做加法运算，并把结果再压入操作数栈（牵扯一些JVM指令）。动态链接：运行期间把符号引用转化为直接引用。）</p>
<p>本地方法栈：线程私有的。存放本地方法。本地方法一般是用于操作系统的交互，使用native 修饰。常用的Object 类中的hashcode、wait 、notify、notifyAll 等都是本地方法。是无法用Java语言编写的方法（一般C++或C）。</p>
<p>程序计数器：线程私有。计数器记录的是虚拟机字节码指令的地址(当前指令的地址)，以便多线程上下文切换后，该线程获得时间片能够得到正确的执行位置。</p>
<p>堆：线程共享，存对象（Math math = new Math()，虚拟机栈存的是math的内存地址，也就是指针指向堆中的Math对象）（public static User user = new User(); 同理方法区存的静态变量也是指向堆中的User对象）</p>
<p>方法区：线程共享：用于存储已经被虚拟机加载的类信息，常量，静态变量等。</p>
<h2 id="类加载器相关"><a href="#类加载器相关" class="headerlink" title="类加载器相关"></a>类加载器相关</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ol>
<li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li>
<li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li>
<li><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li>
</ol>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>类加载过程主要分为三部分：加载、链接、初始化，其中链接又分为验证、准备、解析。</p>
<p>1、加载是指把class字节码文件通过类加载器装载入内存。</p>
<p>2、验证是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。</p>
<p>3、准备阶段是为类变量（static）分配内存，赋予初始值。</p>
<p>4、解析阶段是将常量池内符号引用替换为直接引用的过程。符号引用是指字符串，这个字符串可以唯一性的识别一个方法、变量、类；直接引用可以理解为一个内存地址，或者一个偏移量。</p>
<p><strong>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</strong></p>
<p>5、初始化阶段是对类变量的初始化，是执行类构造器的过程，只对static修饰的变量或者语句进行初始化。</p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父加载器去完成，比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@second/%E9%9D%A2%E8%AF%95/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<p>双亲委派模型的好处：</p>
<p>主要是为了安全性，避免用户自己编写的类动态替换Java的一些核心类，比如String。</p>
<p>同时也避免了类的重复加载，因为JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加载就是不同的两个类。</p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><a target="_blank" rel="noopener" href="https://xiaobubuya.cn/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/#3-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">对象创建</a></p>
<h3 id="指针碰撞和空闲列表"><a href="#指针碰撞和空闲列表" class="headerlink" title="指针碰撞和空闲列表"></a>指针碰撞和空闲列表</h3><p>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump thePointer）。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（FreeList）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p>
<p>下面两张图可以解释指针碰撞和空闲列表：</p>
<p><strong>指针碰撞：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@thired/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200325200409921.png" alt=""></p>
<p> <strong>空闲列表：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@thired/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200325200600794.png" alt=""></p>
<h2 id="堆内存相关"><a href="#堆内存相关" class="headerlink" title="堆内存相关"></a>堆内存相关</h2><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p><strong>堆空间的基本结构：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.png" alt=""></p>
<p>上图所示的 Eden 区、From Survivor0(“From”) 区、To Survivor1(“To”) 区都属于新生代，Old Memory 区属于老年代。</p>
<p>1、对象优先在 eden 区分配</p>
<p>2、大对象直接进入老年代</p>
<p>3、长期存活的对象将进入老年代</p>
<p>4、动态对象年龄判定</p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次（minor gc）新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<p>经过这次 GC 后，Eden 区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次 GC 前的“From”，新的”From”就是上次 GC 前的”To”。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%A0%86%E5%86%85%E5%AD%98.png" alt=""></p>
<h3 id="如何判断一个对象需要被干掉"><a href="#如何判断一个对象需要被干掉" class="headerlink" title="如何判断一个对象需要被干掉"></a>如何判断一个对象需要被干掉</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88.png" alt=""></p>
<p>两个基础方法：</p>
<p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。</p>
<p>2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如Java，C#等都是靠这招去判定对象是否存活的。</p>
<p>GC Roots的对象有：</p>
<p>1、虚拟机栈（栈帧中的本地变量表）中引用的对象</p>
<p>2、方法区中类静态属性引用的对象</p>
<p>3、方法区中常量引用的对象</p>
<p>4、本地方法栈中（Native）引用的对象</p>
<h2 id="JVM调优相关"><a href="#JVM调优相关" class="headerlink" title="JVM调优相关"></a>JVM调优相关</h2><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>减少full gc次数和时间。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>Arthas：命令：dashboard、thread 8、jad反编译</p>
<h2 id="垃圾收集相关"><a href="#垃圾收集相关" class="headerlink" title="垃圾收集相关"></a>垃圾收集相关</h2><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>为了提高应用程序的稳定性，选择正确的<a target="_blank" rel="noopener" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">垃圾收集</a>算法至关重要。</p>
<p>JVM具有四种类型的<em>GC</em>实现：</p>
<ul>
<li>串行垃圾收集器</li>
<li>并行垃圾收集器</li>
<li>CMS垃圾收集器</li>
<li>G1垃圾收集器</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png" alt=""></p>
<p>1、标记-清除算法</p>
<p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
<p>2、标记-复制算法</p>
<p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>3、标记-整理算法</p>
<p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>4、一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt=""></p>
<h4 id="1、Serial-收集器"><a href="#1、Serial-收集器" class="headerlink" title="1、Serial 收集器"></a>1、Serial 收集器</h4><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了</p>
<p>它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/46873026.png" alt=""></p>
<h4 id="2、ParNew-收集器"><a href="#2、ParNew-收集器" class="headerlink" title="2、ParNew 收集器"></a>2、ParNew 收集器</h4><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/22018368.png" alt=""></p>
<h4 id="3、Parallel-Scavenge-收集器"><a href="#3、Parallel-Scavenge-收集器" class="headerlink" title="3、Parallel Scavenge 收集器"></a>3、Parallel Scavenge 收集器</h4><p>它看上去几乎和 ParNew 都一样，<strong>Parallel Scavenge </strong>收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</p>
<h4 id="4、CMS-收集器"><a href="#4、CMS-收集器" class="headerlink" title="4、CMS 收集器"></a>4、CMS 收集器</h4><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p>
<p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt=""></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<h4 id="5、G1-收集器"><a href="#5、G1-收集器" class="headerlink" title="5、G1 收集器"></a>5、G1 收集器</h4><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">xiaobubuya</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xiaobubuya.github.io/Java面试汇总/">https://xiaobubuya.github.io/Java面试汇总/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="social-share pull-right" data-disabled="facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/SpringCloud%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"><i class="fa fa-chevron-left">  </i><span>SpringCloud相关概念介绍</span></a></div><div class="next-post pull-right"><a href="/%E7%BA%A2%E9%BB%91%E6%A0%91/"><span>红黑树</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/xiaobubuya/image@master/img01/jiangnan.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By xiaobubuya</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>